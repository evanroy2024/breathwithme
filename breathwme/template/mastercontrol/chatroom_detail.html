{% extends "exercisebase.html" %}
{% load static %}
{% block title %}
Home - Meditation Dashboard
{% endblock %}

{% block content %}
    <title>Shape Meditation - Breathing Exercise</title>
<style>
 
:root {
    --primary: #7c3aed;
    --primary-light: #a78bfa;
    --secondary: #059669;
    --background: #f3f4f6;
    --text: #1f2937;
    --accent: #f97316;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    background-color: #121212;
    color: var(--text);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 20px;
    transition: background-color 0.5s;
    margin: 0;
    overflow-x: hidden;
}

.container {
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

h1 {
    color: var(--primary);
    margin-bottom: 20px;
    text-align: center;
}

.controls {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 30px;
    background-color: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

label {
    font-weight: 600;
    color: var(--text);
}

select {
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #d1d5db;
    background-color: white;
    font-size: 16px;
    color: var(--text);
    width: 100%;
    -webkit-appearance: menulist; /* Safari compatible dropdown */
    appearance: menulist;
}

.timing-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
}

.timing-input {
    display: flex;
    align-items: center;
    gap: 10px;
}

.timing-input label {
    min-width: 80px;
}

input[type="number"] {
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #d1d5db;
    font-size: 16px;
    width: 100%;
    -webkit-appearance: none; /* Fix for Safari number inputs */
    appearance: none;
}

button {
    background-color: var(--primary);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s;
    width: 100%;
    -webkit-appearance: none; /* Fix for Safari buttons */
    appearance: none;
}

button:hover {
    background-color: var(--primary-light);
}

.meditation-area {
    width: 100%;
    aspect-ratio: 1;
    max-width: 350px;
    position: relative;
    margin-bottom: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
}

#shapeContainer {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translateZ(0); /* Force GPU acceleration */
    -webkit-transform: translateZ(0);
}

#shape {
    width: 100%;
    height: 100%;
    stroke: rgb(255, 255, 255);
    stroke-width: 1;
    fill: none;
    -webkit-transform-origin: center center; /* Fix for Safari transformations */
    transform-origin: center center;
}

#ball {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    -webkit-transform: translate(-50%, -50%);
    will-change: transform; /* Optimize animations */
}

.center-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    -webkit-transform: translate(-50%, -50%);
    font-size: 28px;
    font-weight: 700;
    color: white;
    text-align: center;
    z-index: 10;
    pointer-events: none;
}

.instruction {
    font-size: 24px;
    font-weight: 600;
    color: var(--secondary);
    text-align: center;
    margin-top: 20px;
    min-height: 36px;
}

.status {
    margin-top: 10px;
    padding: 8px 16px;
    background-color: var(--primary-light);
    color: white;
    border-radius: 20px;
    font-weight: 500;
    opacity: 0;
    transition: opacity 0.3s;
}

.status.active {
    opacity: 1;
}

#breath-option {
    display: none; /* Hidden by default */
    margin-top: 20px;
}

/* SVG and glow effects */
svg {
    filter: drop-shadow(0 0 5px rgba(110, 142, 251, 0.6));
    transition: filter 0.5s ease-in-out;
    -webkit-filter: drop-shadow(0 0 5px rgba(110, 142, 251, 0.6));
    -webkit-transition: -webkit-filter 0.5s ease-in-out;
    transform: translateZ(0); /* Fix Safari rendering issues */
    -webkit-transform: translateZ(0);
}

/* Moderate glow effects based on breathing phase */
svg.inhale {
    filter: drop-shadow(0 0 5px rgba(94, 186, 252, 0.7)) 
            drop-shadow(0 0 10px rgba(94, 186, 252, 0.5)) 
            drop-shadow(0 0 18px rgba(0, 119, 255, 0.4));
    -webkit-filter: drop-shadow(0 0 5px rgba(94, 186, 252, 0.7)) 
                   drop-shadow(0 0 10px rgba(94, 186, 252, 0.5)) 
                   drop-shadow(0 0 18px rgba(0, 119, 255, 0.4));
}

svg.exhale {
    filter: drop-shadow(0 0 5px rgba(99, 242, 172, 0.7)) 
            drop-shadow(0 0 10px rgba(38, 209, 134, 0.5))
            drop-shadow(0 0 18px rgba(18, 153, 95, 0.4));
    -webkit-filter: drop-shadow(0 0 5px rgba(99, 242, 172, 0.7)) 
                   drop-shadow(0 0 10px rgba(38, 209, 134, 0.5))
                   drop-shadow(0 0 18px rgba(18, 153, 95, 0.4));
}

svg.hold {
    filter: drop-shadow(0 0 5px rgba(252, 94, 232, 0.7)) 
            drop-shadow(0 0 10px rgba(200, 46, 242, 0.5))
            drop-shadow(0 0 18px rgba(135, 12, 219, 0.4));
    -webkit-filter: drop-shadow(0 0 5px rgba(252, 94, 232, 0.7)) 
                   drop-shadow(0 0 10px rgba(200, 46, 242, 0.5))
                   drop-shadow(0 0 18px rgba(135, 12, 219, 0.4));
}

/* Shape element styles - black fill with colored stroke */
svg circle, 
svg rect, 
svg polygon, 
svg ellipse {
    fill: #121212;
    stroke-width: 0.4;
    transition: all 0.4s ease-in-out;
    -webkit-transition: all 0.4s ease-in-out;
    vector-effect: non-scaling-stroke; /* Helps with Safari rendering */
}

/* Phase-specific shape styles */
svg.inhale circle, 
svg.inhale rect, 
svg.inhale polygon, 
svg.inhale ellipse {
    stroke: rgba(94, 186, 252, 0.4);
}

svg.exhale circle, 
svg.exhale rect, 
svg.exhale polygon, 
svg.exhale ellipse {
    stroke: rgba(99, 242, 172, 0.4);
}

svg.hold circle, 
svg.hold rect, 
svg.hold polygon, 
svg.hold ellipse {
    stroke: rgba(252, 94, 232, 0.4);
}

.shape-meditation {
    margin-left: 0; /* Fix arbitrary negative margin */
    transform: translateX(-30px); /* More precise control for positioning */
    -webkit-transform: translateX(-30px);
}

@media (max-width: 768px) {
    .meditation-area {
        max-width: 90vw;
    }
    
    h1 {
        font-size: 24px;
    }
    
    .instruction {
        font-size: 20px;
    }
    
    .shape-meditation {
        transform: translateX(-20px);
        -webkit-transform: translateX(-20px);
    }
}

@media (max-width: 480px) {
    .controls {
        padding: 15px;
    }
    
    button {
        padding: 10px 16px;
    }
    
    .meditation-area {
        max-width: 95vw;
    }
    
    .shape-meditation {
        transform: translateX(-10px);
        -webkit-transform: translateX(-10px);
    }
}

</style>


    <div class="guide-container" style="display: none;">
        <h2 class="guide-heading">Choose shape to read guide</h2>
        <div class="guide-buttons">
          <a href="{% url 'breathxapp:circle_guide' %}" target="_blank">Circle </a>
          <a href="{% url 'breathxapp:square_guide' %}" target="_blank">Square</a>
          <a href="{% url 'breathxapp:rectangle_guide' %}" target="_blank">Rectangle</a>
          <a href="{% url 'breathxapp:triangle_guide' %}" target="_blank">Triangle</a>
          <a href="{% url 'breathxapp:reverse_triangle_guide' %}" target="_blank">Reverse Triangle</a>
          <a href="{% url 'breathxapp:diamond_guide' %}" target="_blank">Diamond</a>
          <a href="oval.html" style="visibility: hidden;" target="_blank">Oval</a>
          <a href="{% url 'breathxapp:oval_guide' %}" target="_blank">Oval</a>
        </div>
      </div>
      <div class="popup-overlay" id="popupOverlay" style="display: none;">
        <div class="popup">
            <h2>Save this exercise?</h2>
           <p>Your exercise, along with all selected parameters such as shape, will be saved and can be played later from Silent Exercise</p>
            <input type="text" id="exerciseNickname" placeholder="Enter exercise name">
            
            <div class="button-group">
                <button id="saveExerciseButton" class="save-btn">Save</button>
                <button class="cancel-btn" onclick="closePopup()">Don’t Save</button>
            </div>
    
            <input type="hidden" id="csrf_token" value="{{ csrf_token }}">
        </div>
    </div>
    
    <div class="container">
      <div class="main-heading">
        <div class="header-container">
          <!-- <button class="back-button" onclick="window.location.href='{% url 'breathxapp:exercise_list' %}'"> -->
            <!-- <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
          </button> -->
          <h1 class="title" style="display: none;">BreathFree-Meditation</h1>
        </div>
      </div>
      <!-- <hr style="width: 400px; height: 5px;  background: linear-gradient(to right, #6e8efb, #a777e3); border-radius: 10px; margin-bottom: 20px;"> -->
    
          

 
        <div class="meditation-area">
            <div id="shapeContainer">
                <svg id="shape" viewBox="0 0 100 100"></svg>
                <div id="ball"></div>
                <div class="center-text" id="centerText"></div>
            </div>
        </div>
        
        <div style="display: none;" class="instruction" id="instruction"></div>
        <div style="display: none;" class="status" id="status"></div>


        
          
        <div id="breath-option">
            <div class="control-group">
              <label>Breathing Timing (seconds)</label>
              <div class="timing-controls" id="timingControls">
                <div class="timing-input">
                  <label for="inhaleTime">Inhale</label>
                  <!-- <input type="number" id="inhaleTime" min="1" max="20" value="4"> -->
                  <select id="inhaleTime">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                    <option value="30">30</option>
                    <option value="35">35</option>
                    <option value="40">40</option>
                    <option value="45">45</option>
                    <option value="50">50</option>
                    <option value="55">55</option>
                    <option value="60">60</option>
                  </select>
                </div>
                <div class="timing-input" id="holdInControl">
                  <label for="holdInTime">Hold</label>
                  <!-- <input type="number" id="holdInTime" min="0" max="20" value="4"> -->
                  <select id="holdInTime">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                    <option value="30">30</option>
                    <option value="35">35</option>
                    <option value="40">40</option>
                    <option value="45">45</option>
                    <option value="50">50</option>
                    <option value="55">55</option>
                    <option value="60">60</option>
                  </select>
                </div>
                <div class="timing-input">
                  <label for="exhaleTime">Exhale</label>
                  <!-- <input type="number" id="exhaleTime" min="1" max="20" value="4"> -->
                  <select id="exhaleTime">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                    <option value="30">30</option>
                    <option value="35">35</option>
                    <option value="40">40</option>
                    <option value="45">45</option>
                    <option value="50">50</option>
                    <option value="55">55</option>
                    <option value="60">60</option>
                  </select>
                </div>
                <div class="timing-input" id="holdOutControl">
                  <label for="holdOutTime">Hold</label>
                  <!-- <input type="number" id="holdOutTime" min="0" max="20" value="4"> -->
                  <select id="holdOutTime">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                    <option value="30">30</option>
                    <option value="35">35</option>
                    <option value="40">40</option>
                    <option value="45">45</option>
                    <option value="50">50</option>
                    <option value="55">55</option>
                    <option value="60">60</option>
                  </select>
                </div>
              </div>
            </div>
            <button id="breath-close">Close</button>

          </div>

        <div class="controls" id="controls-row" style="display: flex; flex-direction: row;"> 
            <div class="control-group">
                <label for="shapeSelect"></label>
                <select id="shapeSelect" >
                    <option value="circle">Circle (inhale/exhale)</option>
                    <option value="square">Square (inhale/hold in/exhale/hold out)</option>
                    <option value="rectangle">Rectangle (inhale/hold in/exhale/hold out) </option>
                    <option value="triangle">Triangle (inhale/exhale/hold out)</option>
                    <option value="reverseTriangle">Reverse Triangle (inhale/hold in/exhale) </option>
                    <option value="diamond">Diamond (inhale/hold in/exhale/hold out)</option>
                    <option value="oval">Oval (inhale/exhale)</option>
                </select>
                
            </div>
            
<script>
document.getElementById('shapeSelect').addEventListener('change', function() {
    // Get all options
    const options = this.querySelectorAll('option');
    
    // Remove existing checkmarks
    options.forEach(option => {
        option.textContent = option.textContent.replace('✓ ', '');
    });
    
    // Add checkmark to selected option
    const selectedOption = this.options[this.selectedIndex];
    selectedOption.textContent = '✓ ' + selectedOption.textContent;
});

// Set initial checkmark on page load
window.addEventListener('load', function() {
    const select = document.getElementById('shapeSelect');
    const selectedOption = select.options[select.selectedIndex];
    selectedOption.textContent = '✓ ' + selectedOption.textContent;
});
</script>
            <button id="breathtoggleBtn">Breath</button>
            <button id="startButton">Start </button>
        </div>
        
        <div class="action-buttons" >
            <button id="voice-start" class="voice-off" aria-label="Voice">
              <i class="fas fa-volume-mute"></i>
            </button>
            <button aria-label="Vibration" id="vibration-button-set" style="width: 50px; display: inline-flex; align-items: center; justify-content: center; padding: 0; border: none; ">
            <img src="{% static 'v2.png' %}" alt="" style="max-width: 100%; max-height: 100%; object-fit: contain;">
            </button>

            <button aria-label="Save" id="save-exercise-button-id">
              <i class="fas fa-save"></i>
            </button>
            <button aria-label="Guide" id="guide-button-id">
              <i class="fas fa-question-circle"></i>
            </button>
          </div>
          <script>
            const settingsButton = document.getElementById("settings-buttons");
            const actionButtons = document.querySelector(".action-buttons");
          
            settingsButton.addEventListener("click", () => {
              // Read the current state from the data-toggle attribute
              const isVisible = settingsButton.getAttribute("data-toggle") === "true";
              
              // Toggle visibility based on the current state
              if (isVisible) {
                actionButtons.style.display = "none";
                settingsButton.setAttribute("data-toggle", "false");
              } else {
                actionButtons.style.display = "flex";  // Show the buttons
                settingsButton.setAttribute("data-toggle", "true");
              }
            });
          </script>
          
<button id="reload-all">Re-Connect</button>
<button id="leave-group-session" style="background-color: #e63946; color: white;">🏃‍♂️ Leave</button>

          
            <!-- Section for guide  -->
         <section class="guide-container-end" style="
  padding: 1.5rem;
  color: #e0e0e0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  background-color: #1a1a1a;
  border-radius: 12px;
  margin: 1rem auto;
  max-width: 100%;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
">
  <h2 style="
    color: #39e5ff;
    font-size: 1.4rem;
    margin-bottom: 1.5rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    border-bottom: 1px solid rgba(57, 229, 255, 0.2);
    padding-bottom: 0.75rem;
  ">How to Practice Breathing</h2>
  
  <div class="guide-step" style="
    margin-bottom: 1.5rem;
    padding-left: 1rem;
    border-left: 3px solid rgba(57, 229, 255, 0.6);
  ">
    <h3 style="
      color: #ffffff;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      font-weight: 500;
    ">Step 1: Find Your Position</h3>
    <p style="
      line-height: 1.6;
      color: #cdcdcd;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    ">Sit comfortably with your back straight or lie down in a quiet place. Place one hand on your chest and the other on your abdomen to feel your breath movement.</p>
  </div>
  
  <div class="guide-step" style="
    margin-bottom: 1.5rem;
    padding-left: 1rem;
    border-left: 3px solid rgba(57, 229, 255, 0.6);
  ">
    <h3 style="
      color: #ffffff;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      font-weight: 500;
    ">Step 2: Breathing Rhythm</h3>
    <p style="
      line-height: 1.6;
      color: #cdcdcd;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    ">Inhale slowly through your nose for a count of 4, feeling your abdomen expand. Hold briefly, then exhale through your mouth for a count of 6.</p>
  </div>
  
  <div class="guide-step" style="
    margin-bottom: 1.5rem;
    padding-left: 1rem;
    border-left: 3px solid rgba(57, 229, 255, 0.6);
  ">
    <h3 style="
      color: #ffffff;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      font-weight: 500;
    ">Step 3: Maintain Focus</h3>
    <p style="
      line-height: 1.6;
      color: #cdcdcd;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    ">Keep your attention on your breath. When your mind wanders, gently bring your focus back to your breathing pattern without judgment.</p>
  </div>

  <div class="tip-box" style="
    background-color: rgba(57, 229, 255, 0.1);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
    border: 1px solid rgba(57, 229, 255, 0.2);
  ">
    <div style="
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    ">
      <span style="
        color: #39e5ff;
        font-size: 1.2rem;
        margin-right: 0.5rem;
      ">💡</span>
      <h4 style="
        color: #39e5ff;
        font-size: 1rem;
        margin: 0;
        font-weight: 500;
      ">Pro Tip</h4>
    </div>
    <p style="
      line-height: 1.6;
      color: #cdcdcd;
      font-size: 0.95rem;
      margin: 0;
    ">Try practicing at the same time each day to build a consistent habit. Even 5 minutes of focused breathing can help reduce stress and improve mindfulness.</p>
  </div>
</section>      
    </div>

 <!-- Add this Font Awesome link in the head of your HTML -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

<!-- Replace your existing voice button with this -->

<script>
    // DOM Elements
const shapeSelect = document.getElementById('shapeSelect');
const inhaleTimeInput = document.getElementById('inhaleTime');
const holdInTimeInput = document.getElementById('holdInTime');
const exhaleTimeInput = document.getElementById('exhaleTime');
const holdOutTimeInput = document.getElementById('holdOutTime');
const holdInControl = document.getElementById('holdInControl');
const holdOutControl = document.getElementById('holdOutControl');
const startButton = document.getElementById('startButton');
const timingControls = document.getElementById('timingControls');
const shapeElement = document.getElementById('shape');
const ball = document.getElementById('ball');
const instruction = document.getElementById('instruction');
const status = document.getElementById('status');
const centerText = document.getElementById('centerText');
const voiceButton = document.getElementById('voice-start');

// Animation variables
let animationId = null;
let isAnimating = false;
let currentPhase = 0;
let currentTime = 0;
let phaseTimes = [];
let points = [];
let totalTime = 0;
let phaseNames = [];
let lastTimestamp = 0;
let lastSpokenPhase = -1; // Track the last spoken phase
let speechSynthesis = window.speechSynthesis; // Speech synthesis API
let voiceEnabled = false; // Voice starts off by default

// Initialize voice button
function initVoiceButton() {
    // Add icon to button
    voiceButton.innerHTML = '<i class="fas fa-volume-mute"></i>';
    voiceButton.classList.add('voice-off');
    
    // Add event listener
    voiceButton.addEventListener('click', toggleVoice);
}

// For Vibration in React native app ------------------------------------------------------------------------------
// Add vibration state variable
let vibrationEnabled = true;

// Modify your existing notifyPhaseChange function
function notifyPhaseChange(phase) { 
  // Always log the phase change 
  console.log("Phase changed to:", phase); 
   
  // Only send message if vibration is enabled
  if (vibrationEnabled) {
    // Send a message to the React Native WebView if available 
    if (window.ReactNativeWebView) { 
      window.ReactNativeWebView.postMessage(JSON.stringify({ 
        type: 'phaseChange', 
        phase: phase 
      })); 
      console.log("post message sent"); 
    } else { 
      console.log("ReactNativeWebView not available - would have sent message:", phase); 
    } 
  } else {
    console.log("Vibration disabled - message not sent");
  }
}

// Add click event to your existing button
document.getElementById('vibration-button-set').addEventListener('click', function() {
  vibrationEnabled = !vibrationEnabled;
  
  // Toggle visual state
  if (vibrationEnabled) {
    this.classList.remove('off');
  } else {
    this.classList.add('off');
  }
});
// Voice -------------------------------------------------------------------
const audioFiles = {
    'Inhale': new Audio("{% static 'voices/inhale.mp3' %}"),
    'Hold': new Audio("{% static 'voices/hold.mp3' %}"),
    'Exhale': new Audio("{% static 'voices/exhale.mp3' %}")
};

// Replace the entire toggleVoice function:
function toggleVoice() {
    voiceEnabled = !voiceEnabled;
    
    if (voiceEnabled) {
        voiceButton.innerHTML = '<i class="fas fa-volume-up"></i>';
        voiceButton.classList.remove('voice-off');
        voiceButton.classList.add('voice-on');
        
        // If currently animating, speak the current phase
        if (isAnimating && currentPhase >= 0) {
            speakPhase(phaseNames[currentPhase]);
        }
    } else {
        voiceButton.innerHTML = '<i class="fas fa-volume-mute"></i>';
        voiceButton.classList.remove('voice-on');
        voiceButton.classList.add('voice-off');
        
        // Stop any playing audio
        for (const phase in audioFiles) {
            audioFiles[phase].pause();
            audioFiles[phase].currentTime = 0;
        }
    }
}

// Shape drawing functions
const drawShape = {
    circle: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<circle cx="50" cy="50" r="45" />';
        return getCirclePoints(50, 50, 45);
    },
    square: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<rect x="10" y="10" width="80" height="80" />';
        return getSquarePoints(10, 10, 90, 90);
    },
    rectangle: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        // 5:8 ratio
        const width = 80;
        const height = width * (5/8);
        const x = 10;
        const y = (100 - height) / 2;
        shapeElement.innerHTML = `<rect x="${x}" y="${y}" width="${width}" height="${height}" />`;
        return getSquarePoints(x, y, x + width, y + height);
    },
    triangle: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<polygon points="10,90 50,10 90,90" />';
        return getTrianglePoints(10, 90, 50, 10, 90, 90);
    },

    reverseTriangle: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<polygon points="10,10 90,10 50,90" />';
        return getTrianglePoints(10, 10, 90, 10, 50, 90);
    },
    diamond: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<polygon points="50,10 90,50 50,90 10,50" />';
        return getDiamondPoints(50, 10, 90, 50, 50, 90, 10, 50);
    },
    oval: () => {
        shapeElement.setAttribute('viewBox', '0 0 100 100');
        shapeElement.innerHTML = '<ellipse cx="50" cy="50" rx="40" ry="25" />';
        return getOvalPoints(50, 50, 40, 25);
    }
};

// Replace the entire init function:
function init() {
    updateTimingControls();
    drawCurrentShape();
    initVoiceButton();
    
    // Preload audio files
    for (const phase in audioFiles) {
        audioFiles[phase].load();
        audioFiles[phase].preload = 'auto';
    }
    
    // Event listeners
    shapeSelect.addEventListener('change', () => {
        updateTimingControls();
        drawCurrentShape();
        syncInputs(); // Sync inputs when shape changes
        if (isAnimating) {
            stopAnimation();
            startAnimation();
        }
    });
    
    // Add event listeners to all inputs to auto-adjust when values change and sync related inputs
    inhaleTimeInput.addEventListener('input', () => {
        syncInputs();
        autoAdjustAnimation();
    });
    
    holdInTimeInput.addEventListener('input', () => {
        syncInputs();
        autoAdjustAnimation();
    });
    
    exhaleTimeInput.addEventListener('input', () => {
        syncInputs();
        autoAdjustAnimation();
    });
    
    holdOutTimeInput.addEventListener('input', () => {
        syncInputs();
        autoAdjustAnimation();
    });
    
    startButton.addEventListener('click', toggleAnimation);
    
    // Initial sync
    syncInputs();
}

// Sync input values based on the selected shape
function syncInputs() {
    const shape = shapeSelect.value;
    
    switch (shape) {
        case 'circle':
            // For circle: exhaleTime = inhaleTime
            exhaleTimeInput.value = inhaleTimeInput.value;
            break;
            
        case 'square':
            // For square: all inputs = inhaleTime
            holdInTimeInput.value = inhaleTimeInput.value;
            exhaleTimeInput.value = inhaleTimeInput.value;
            holdOutTimeInput.value = inhaleTimeInput.value;
            break;
            
        case 'rectangle':
            // For rectangle: exhaleTime = inhaleTime, holdOutTime = holdInTime
            exhaleTimeInput.value = inhaleTimeInput.value;
            holdOutTimeInput.value = holdInTimeInput.value;
            break;
            
        // No changes for other shapes
        case 'triangle':
        case 'reverseTriangle':
        case 'diamond':
        case 'oval':
            // No syncing needed
            break;
    }
}

// Replace the entire speakPhase function:
function speakPhase(phaseText) {
    // Only play if voice is enabled
    if (!voiceEnabled) return;
    
    // Stop any currently playing audio first
    for (const phase in audioFiles) {
        audioFiles[phase].pause();
        audioFiles[phase].currentTime = 0;
    }
    
    // Play the appropriate audio file
    if (audioFiles[phaseText]) {
        // Reset audio to beginning
        audioFiles[phaseText].currentTime = 0;
        
        // Play the audio file immediately
        const playPromise = audioFiles[phaseText].play();
        
        // Handle potential play() promise rejection
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.log('Audio play failed:', error);
            });
        }
    }
}

// Update timing controls based on selected shape
function updateTimingControls() {
    const shape = shapeSelect.value;
    
    // First reset all inputs to be visible
    inhaleTimeInput.parentElement.style.display = 'flex';
    holdInTimeInput.parentElement.style.display = 'flex';
    exhaleTimeInput.parentElement.style.display = 'flex';
    holdOutTimeInput.parentElement.style.display = 'flex';
    
    // Then hide entire controls based on shape
    switch (shape) {
        case 'circle':
            // Only inhale and exhale controls visible
            holdInControl.style.display = 'none';
            holdOutControl.style.display = 'none';
            
            // For circle, hide exhale input (but keep control visible)
            exhaleTimeInput.parentElement.style.display = 'none';
            break;
        case 'oval':
            // Only inhale and exhale controls visible
            holdInControl.style.display = 'none';
            holdOutControl.style.display = 'none';
            
            // For circle, hide exhale input (but keep control visible)
            break;
            
        case 'triangle':
            document.querySelector('.center-text').style.top = '58%';
            holdInControl.style.display = 'flex';
            holdOutControl.style.display = 'none';
            break;
        case 'reverseTriangle':
            // Inhale, hold, exhale controls visible
            document.querySelector('.center-text').style.top = '42%';

            holdInControl.style.display = 'flex';
            holdOutControl.style.display = 'none';
            break;
            
        case 'square':
            // All controls visible but hide specific inputs
            holdInControl.style.display = 'flex';
            holdOutControl.style.display = 'flex';
            
            // For square, hide all inputs except the first one
            
            holdInTimeInput.parentElement.style.display = 'none';
            exhaleTimeInput.parentElement.style.display = 'none';
            holdOutTimeInput.parentElement.style.display = 'none';
            break;
            
        case 'rectangle':
            // All controls visible but hide specific inputs
            holdInControl.style.display = 'flex';
            holdOutControl.style.display = 'flex';
            
            // For rectangle, only first two inputs are visible
            exhaleTimeInput.parentElement.style.display = 'none';
            holdOutTimeInput.parentElement.style.display = 'none';
            break;
            
        case 'diamond':
            // All controls visible
            holdInControl.style.display = 'flex';
            holdOutControl.style.display = 'flex';
            break;
    }
}
// Draw the current shape
function drawCurrentShape() {
    const shape = shapeSelect.value;
    points = drawShape[shape]();
    positionBall(points[0]);
}

// Position the ball at the given point
function positionBall(point) {
    ball.style.left = `${point.x}%`;
    ball.style.top = `${point.y}%`;
}

// Auto-adjust animation when inputs change
function autoAdjustAnimation() {
    if (isAnimating) {
        stopAnimation();
        startAnimation();
    }
}

// Toggle animation
function toggleAnimation() {
    if (isAnimating) {
        stopAnimation();
        startButton.textContent = 'Start';
        instruction.textContent = '';
        status.classList.remove('active');
    } else {
        startAnimation();
        startButton.textContent = 'Stop';
    }
}

// Start the animation
function startAnimation() {
    if (isAnimating) return;
    
    const shape = shapeSelect.value;
    setupAnimationParameters(shape);
    
    isAnimating = true;
    currentPhase = 0;
    currentTime = 0;
    
    // Start the animation loop
    lastTimestamp = performance.now();
    animationId = requestAnimationFrame(animate);
    
    // Make sure status is active
    status.classList.add('active');
    
    // Speak the initial phase if voice is enabled
    if (voiceEnabled) {
        speakPhase(phaseNames[0]);
        lastSpokenPhase = 0;
    }
}

// Replace the entire stopAnimation function:
function stopAnimation() {
    if (!isAnimating) return;
    
    cancelAnimationFrame(animationId);
    isAnimating = false;
    centerText.textContent = '';
    status.classList.remove('active');
    
    // Remove all glow effect classes
    shapeElement.classList.remove('inhale', 'exhale', 'hold');
    
    // Stop any playing audio
    for (const phase in audioFiles) {
        audioFiles[phase].pause();
        audioFiles[phase].currentTime = 0;
    }
    
    lastSpokenPhase = -1;
}
// Setup animation parameters based on the shape
function setupAnimationParameters(shape) {
    phaseTimes = [];
    phaseNames = [];
    
    const inhaleTime = parseFloat(inhaleTimeInput.value) || 4;
    const exhaleTime = parseFloat(exhaleTimeInput.value) || 4;
    const holdInTime = parseFloat(holdInTimeInput.value) || 4;
    const holdOutTime = parseFloat(holdOutTimeInput.value) || 4;
    
    switch (shape) {
        case 'circle':
        case 'oval':
            phaseTimes = [inhaleTime, exhaleTime];
            phaseNames = ['Inhale', 'Exhale'];
            break;
            
        case 'triangle':
            phaseTimes = [inhaleTime, exhaleTime, holdInTime];
            phaseNames = ['Inhale', 'Exhale', 'Hold'];
            break;
        case 'reverseTriangle':
            phaseTimes = [inhaleTime, holdInTime, exhaleTime];
            phaseNames = ['Inhale', 'Hold', 'Exhale'];
            break;
            
        case 'square':
        case 'rectangle':
        case 'diamond':
            phaseTimes = [inhaleTime, holdInTime, exhaleTime, holdOutTime];
            phaseNames = ['Inhale', 'Hold', 'Exhale', 'Hold'];
            break;
    }
    
    totalTime = phaseTimes.reduce((sum, time) => sum + time, 0);
}

// Add these JavaScript updates

// Replace the animate function with this improved version
function animate(timestamp) {
    const deltaTime = (timestamp - lastTimestamp) / 1000; // Convert to seconds
    lastTimestamp = timestamp;
    
    // Update the current time
    currentTime += deltaTime;
    
    // Calculate the phase boundaries
    let phaseStartTime = 0;
    for (let i = 0; i < currentPhase; i++) {
        phaseStartTime += phaseTimes[i];
    }
    
    const phaseEndTime = phaseStartTime + phaseTimes[currentPhase];
    
      // Update inside the animate function where phase changes
    if (currentTime >= phaseEndTime) {
        // Update the phase
        currentPhase = (currentPhase + 1) % phaseTimes.length;
        
        // If we've completed a full cycle
        if (currentPhase === 0) {
            currentTime = 0;
            phaseStartTime = 0;
        } else {
            // Recalculate the phase start time for the new phase
            phaseStartTime = 0;
            for (let i = 0; i < currentPhase; i++) {
                phaseStartTime += phaseTimes[i];
            }
        }
        
        // Notify React Native about phase change
        notifyPhaseChange(phaseNames[currentPhase]);
        
        // Speak the new phase if voice is enabled
        if (voiceEnabled && currentPhase !== lastSpokenPhase) {
            speakPhase(phaseNames[currentPhase]);
            lastSpokenPhase = currentPhase;
        }
    }
    
    // Calculate progress within the current phase (after phase update)
    const phaseProgress = (currentTime - phaseStartTime) / phaseTimes[currentPhase];
    
    // Update the instruction text, center text, and status
    instruction.textContent = phaseNames[currentPhase];
    centerText.textContent = phaseNames[currentPhase];
    status.textContent = phaseNames[currentPhase];
    
    // Update glow effect classes based on current phase
    shapeElement.classList.remove('inhale', 'exhale', 'hold');
    
    if (phaseNames[currentPhase] === 'Inhale') {
        shapeElement.classList.add('inhale');
    } else if (phaseNames[currentPhase] === 'Exhale') {
        shapeElement.classList.add('exhale');
    } else if (phaseNames[currentPhase] === 'Hold') {
        shapeElement.classList.add('hold');
    }
    
    // Calculate the position of the ball
    // Use a single smooth calculation for the ball position
    const currentPoint = getPointsForPhase(currentPhase, phaseProgress);
    positionBall(currentPoint);
    
    // Continue the animation
    animationId = requestAnimationFrame(animate);
}

// In the stopAnimation function, add code to remove the glow classes:
function stopAnimation() {
    if (!isAnimating) return;
    
    cancelAnimationFrame(animationId);
    isAnimating = false;
    centerText.textContent = '';
    status.classList.remove('active');
    
    // Remove all glow effect classes
    shapeElement.classList.remove('inhale', 'exhale', 'hold');
    
    // Stop any ongoing speech
    speechSynthesis.cancel();
    lastSpokenPhase = -1;
}
// Replace this function in your code
// Replace or update the getPointsForPhase function with this logic
function getPointsForPhase(phase, progress) {
    const shape = shapeSelect.value;
    const numPhases = phaseTimes.length;
    
    // For circle and oval, each phase should complete a full 360-degree cycle
    if (shape === 'circle' || shape === 'oval') {
        // For each phase, go full circle from 12 o'clock to 12 o'clock
        // Start at top (-90 degrees) and make a full 360 rotation
        const angle = -90 + (progress * 360);
        const radians = angle * Math.PI / 180;
        
        if (shape === 'circle') {
            const radius = 45;
            const x = 50 + radius * Math.cos(radians);
            const y = 50 + radius * Math.sin(radians);
            return { x, y };
        } else { // oval
            const rx = 40;
            const ry = 25;
            const x = 50 + rx * Math.cos(radians);
            const y = 50 + ry * Math.sin(radians);
            return { x, y };
        }
    } else {
        // Special case for reverseTriangle - adjust the starting point
        if (shape === 'reverseTriangle') {
            // For reverse triangle, we want to start from the bottom point (50,90)
            // Remap the points so phase 0 starts at bottom point
            
            const pointsPerPhase = points.length / numPhases;
            
            // Calculate the index for the bottom point (which is at 50,90)
            const bottomPointIndex = points.findIndex(p => 
                Math.abs(p.x - 50) < 1 && Math.abs(p.y - 90) < 1
            );
            
            // If bottom point found, adjust the start index
            if (bottomPointIndex >= 0) {
                const adjustedPhase = (phase + (bottomPointIndex / pointsPerPhase)) % numPhases;
                const startIdx = Math.floor(adjustedPhase * pointsPerPhase) % points.length;
                const endIdx = Math.floor((adjustedPhase + 1) * pointsPerPhase) % points.length;
                
                // If start and end are the same, we need to wrap around
                if (startIdx === endIdx) {
                    return points[startIdx];
                }
                
                // For shapes with corners, we need to interpolate between points
                let startPoint = points[startIdx];
                let endPoint = (endIdx === 0) ? points[points.length - 1] : points[endIdx];
                
                const x = startPoint.x + (endPoint.x - startPoint.x) * progress;
                const y = startPoint.y + (endPoint.y - startPoint.y) * progress;
                
                return { x, y };
            }
        }
        
        // For other polygons, each phase maps to a specific segment of the shape
        const pointsPerPhase = points.length / numPhases;
        const startIdx = Math.floor(phase * pointsPerPhase);
        const endIdx = Math.floor((phase + 1) * pointsPerPhase) % points.length;
        
        // If start and end are the same, we need to wrap around
        if (startIdx === endIdx) {
            return points[startIdx];
        }
        
        // For shapes with corners, we need to interpolate between points
        let startPoint = points[startIdx];
        let endPoint;
        
        // Handle the case where endIdx is 0 (wrap around to the beginning)
        if (endIdx === 0) {
            endPoint = points[points.length - 1];
        } else {
            endPoint = points[endIdx];
        }
        
        const x = startPoint.x + (endPoint.x - startPoint.x) * progress;
        const y = startPoint.y + (endPoint.y - startPoint.y) * progress;
        
        return { x, y };
    }
}

// And update the getTrianglePoints function for reverse triangle
function getTrianglePoints(x1, y1, x2, y2, x3, y3) {
    // Create more points along each side for smooth animation
    const points = [];
    const numPointsPerSide = 20;
    
    // For reverse triangle, the order matters
    // The point we want to start with should be the first one added
    
    // If this is a reverse triangle (where y3 > y1 and y3 > y2)
    const isReverseTriangle = (y3 > y1 && y3 > y2);
    
    if (isReverseTriangle) {
        // Start with bottom point and go counterclockwise
        
        // Side 1: bottom point to top-left
        for (let i = 0; i <= numPointsPerSide; i++) {
            points.push({
                x: x3 + (x1 - x3) * (i / numPointsPerSide),
                y: y3 + (y1 - y3) * (i / numPointsPerSide)
            });
        }
        
        // Side 2: top-left to top-right
        for (let i = 1; i <= numPointsPerSide; i++) {
            points.push({
                x: x1 + (x2 - x1) * (i / numPointsPerSide),
                y: y1 + (y2 - y1) * (i / numPointsPerSide)
            });
        }
        
        // Side 3: top-right back to bottom point
        for (let i = 1; i < numPointsPerSide; i++) {
            points.push({
                x: x2 + (x3 - x2) * (i / numPointsPerSide),
                y: y2 + (y3 - y2) * (i / numPointsPerSide)
            });
        }
    } else {
        // Regular triangle - same as before
        // Side 1: first point to second point
        for (let i = 0; i <= numPointsPerSide; i++) {
            points.push({
                x: x1 + (x2 - x1) * (i / numPointsPerSide),
                y: y1 + (y2 - y1) * (i / numPointsPerSide)
            });
        }
        
        // Side 2: second point to third point
        for (let i = 1; i <= numPointsPerSide; i++) {
            points.push({
                x: x2 + (x3 - x2) * (i / numPointsPerSide),
                y: y2 + (y3 - y2) * (i / numPointsPerSide)
            });
        }
        
        // Side 3: third point back to first point
        for (let i = 1; i < numPointsPerSide; i++) {
            points.push({
                x: x3 + (x1 - x3) * (i / numPointsPerSide),
                y: y3 + (y1 - y3) * (i / numPointsPerSide)
            });
        }
    }
    
    return points;
}
// Helper functions to generate points for shapes
function getCirclePoints(cx, cy, r) {
    const points = [];
    const numPoints = 60; // More points for smoother circle
    
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI - Math.PI/2; // Start at top
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        points.push({ x, y });
    }
    
    return points;
}

function getSquarePoints(x1, y1, x2, y2) {
    // Create more points along each side for smooth animation
    const points = [];
    const numPointsPerSide = 15;
    
    // Top side: left to right
    for (let i = 0; i <= numPointsPerSide; i++) {
        points.push({
            x: x1 + (x2 - x1) * (i / numPointsPerSide),
            y: y1
        });
    }
    
    // Right side: top to bottom
    for (let i = 1; i <= numPointsPerSide; i++) {
        points.push({
            x: x2,
            y: y1 + (y2 - y1) * (i / numPointsPerSide)
        });
    }
    
    // Bottom side: right to left
    for (let i = 1; i <= numPointsPerSide; i++) {
        points.push({
            x: x2 - (x2 - x1) * (i / numPointsPerSide),
            y: y2
        });
    }
    
    // Left side: bottom to top
    for (let i = 1; i < numPointsPerSide; i++) {
        points.push({
            x: x1,
            y: y2 - (y2 - y1) * (i / numPointsPerSide)
        });
    }
    
    return points;
}

function getTrianglePoints(x1, y1, x2, y2, x3, y3) {
    // Create more points along each side for smooth animation
    const points = [];
    const numPointsPerSide = 20;
    
    // Side 1: first point to second point
    for (let i = 0; i <= numPointsPerSide; i++) {
        points.push({
            x: x1 + (x2 - x1) * (i / numPointsPerSide),
            y: y1 + (y2 - y1) * (i / numPointsPerSide)
        });
    }
    
    // Side 2: second point to third point
    for (let i = 1; i <= numPointsPerSide; i++) {
        points.push({
            x: x2 + (x3 - x2) * (i / numPointsPerSide),
            y: y2 + (y3 - y2) * (i / numPointsPerSide)
        });
    }
    
    // Side 3: third point back to first point
    for (let i = 1; i < numPointsPerSide; i++) {
        points.push({
            x: x3 + (x1 - x3) * (i / numPointsPerSide),
            y: y3 + (y1 - y3) * (i / numPointsPerSide)
        });
    }
    
    return points;
}

function getDiamondPoints(x1, y1, x2, y2, x3, y3, x4, y4) {
    // Create more points along each side for smooth animation
    const points = [];
    const numPointsPerSide = 15;
    
    // Side 1: top to right
    for (let i = 0; i <= numPointsPerSide; i++) {
        points.push({
            x: x1 + (x2 - x1) * (i / numPointsPerSide),
            y: y1 + (y2 - y1) * (i / numPointsPerSide)
        });
    }
    
    // Side 2: right to bottom
    for (let i = 1; i <= numPointsPerSide; i++) {
        points.push({
            x: x2 + (x3 - x2) * (i / numPointsPerSide),
            y: y2 + (y3 - y2) * (i / numPointsPerSide)
        });
    }
    
    // Side 3: bottom to left
    for (let i = 1; i <= numPointsPerSide; i++) {
        points.push({
            x: x3 + (x4 - x3) * (i / numPointsPerSide),
            y: y3 + (y4 - y3) * (i / numPointsPerSide)
        });
    }
    
    // Side 4: left to top
    for (let i = 1; i < numPointsPerSide; i++) {
        points.push({
            x: x4 + (x1 - x4) * (i / numPointsPerSide),
            y: y4 + (y1 - y4) * (i / numPointsPerSide)
        });
    }
    
    return points;
}

function getOvalPoints(cx, cy, rx, ry) {
    const points = [];
    const numPoints = 60; // More points for smoother oval
    
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI - Math.PI/2; // Start at top
        const x = cx + rx * Math.cos(angle);
        const y = cy + ry * Math.sin(angle);
        points.push({ x, y });
    }
    
    return points;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initialize the app
window.addEventListener('load', init);
</script>


<script>
    const toggleBtn = document.getElementById("breathtoggleBtn");
    const breathOption = document.getElementById("breath-option");
  
    toggleBtn.addEventListener("click", () => {
      breathOption.style.display = breathOption.style.display === "none" ? "block" : "none";
    });
  </script>
<style>
    #controls-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px; /* Reduced gap between buttons */
      flex-wrap: nowrap; /* Force all in one row */
      padding: 10px;
      max-width: 450px;
      width: 100%;
    }
  
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
  
    .control-group label {
      white-space: nowrap;
      font-weight: 500;
    }
  
    #shapeSelect {
      width: 180px; /* fixed width like buttons */
      padding: 8px 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
  
    #controls-row button {
      min-width: 180px;
      padding: 10px 15px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #6e8efb, #a777e3);
      color: #fff;
      cursor: pointer;
      transition: 0.2s;
      white-space: nowrap;
    }
  
    #controls-row button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
  
    #controls-row button i {
      margin-right: 6px;
    }
  
    /* Optional: Responsive fallback for small screens */
    @media (max-width: 600px) {
      #controls-row {
        flex-wrap: wrap;
        justify-content: center;
      }
  
      .control-group,
      #controls-row button {
        width: 100%;
        justify-content: center;
      }
  
      #shapeSelect {
        width: 100%;
      }
    }
  
    /* Dropdown (Select) Styling */
    #shapeSelect {
      width: 100%; /* Ensure the dropdown takes up the full width of its container */
      max-width: 100px; /* Limit the maximum width to 180px */
      padding: 10px 12px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #6e8efb, #a777e3);
      color: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      appearance: none;
      cursor: pointer;
      transition: 0.2s ease-in-out;
      outline: none;
    }
  
    /* Dropdown options */
    #shapeSelect option {
      background-color: #f9f9f9;
      color: #333;
      padding: 10px;
      font-size: 14px;
    }
  
    /* Breathing option container */
    #breath-option {
      background: #f7f7f7;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
    }
  
    /* Control group styling */
    .control-group {
      margin-bottom: 20px;
    }
  
    /* Labels */
    .control-group label {
      font-size: 16px;
      font-weight: 500;
      color: #333;
      margin-bottom: 10px;
      display: block;
    }
  
    /* Timing control container using grid */
    .timing-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }
  
    /* Timing input containers */
    .timing-input {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
  
    /* Timing input label styling */
    .timing-input label {
      font-size: 14px;
      color: #666;
    }
  
    /* Input styling */
    .timing-input input {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      outline: none;
      background-color: #fff;
      transition: all 0.3s ease;
    }
  
    /* Focus effect */
    .timing-input input:focus {
      border-color: #6e8efb;
      box-shadow: 0 0 5px rgba(110, 142, 251, 0.5);
    }
  
    /* Space adjustment for last input in a group */
    .timing-input:last-child {
      margin-bottom: 0;
    }
  
    /* Responsive adjustments */
    @media (max-width: 600px) {
      /* Stack inputs in a single column */
      .timing-controls {
        grid-template-columns: 1fr; /* Stack inputs on top of each other */
      }
  
      /* Dropdown (Select) styling for small screens */
      #shapeSelect {
        max-width: 100%; /* Make dropdown full width on small screens */
      }
  
      /* Buttons */
      button {
        width: 100%; /* Ensure buttons take full width on small screens */
        margin-bottom: 10px; /* Add space between buttons */
        padding: 12px 15px; /* Adjust button size */
      }
    }
  
    #controls-row button {
      min-width: 100px;
    }

    #controls-row {
        border: 2px solid goldenrod;
        background: rgb(1, 1, 1);
    }
    .action-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  align-items: center;
  padding: 12px;
  background: transparent;
}

.action-buttons button {
  width: 60px;
  height: 60px;
  background: #1e1e1e;
  border: 2px solid #6e8efb;
  border-radius: 50%;
  color: #ffffff;
  font-size: 20px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: all 0.3s ease;
  box-shadow: 0 0 6px rgba(110, 142, 251, 0.4);
  position: relative;
}

.action-buttons button:hover {
  background: #6e8efb;
  color: #fff;
  box-shadow: 0 0 12px #6e8efb, 0 0 18px #a777e3;
  transform: scale(1.08);
}

.action-buttons button:active {
  transform: scale(0.95);
  box-shadow: 0 0 10px #a777e3 inset;
}

.action-buttons button i {
  pointer-events: none;
}
#controls-row button {
    background: linear-gradient(135deg, #FFD700, #FFA500);

}
#controls-row button {
  width: 80px;
  height: 41px;
  background: #1e1e1e; /* Button background */
  color: #fff;
  font-size: 14px;
  border: 5px solid transparent; /* Transparent border to create space */
  border-radius: 10px; /* Rounded corners */
  padding: 8px 16px;
  position: relative;
  cursor: pointer;
  transition: all 0.3s ease;
  background-clip: padding-box; /* Ensure background doesn't cover the border */
border: 2px solid gold;
}
#controls-row{
    border: 1px solid white;
    max-width:500px;
}
    .shape-meditation {
  font-size: 1.7rem;
  color: #FFD700; /* Gold color */
  display: flex;
  align-items: center;
  cursor: pointer;
  position: relative;
  padding-bottom: 10px;
  width: auto; /* Ensure it adjusts to content width */
  white-space: nowrap; /* Prevent the text from wrapping */
}

.shape-meditation .back-arrow {
  background: none;
  border: none;
  color: #FFD700; /* Gold color */
  font-size: 1.5rem;
  margin-right: 10px; /* Space between the arrow and text */
  cursor: pointer;
  transition: transform 0.3s ease;
}

/* Always visible underline */
.shape-meditation::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(135deg, #FFD700, #FFA500); /* Gold to orange gradient */
}

/* Hover effect for back arrow */
.shape-meditation:hover .back-arrow {
  transform: translateX(-5px); /* Move the arrow slightly on hover */
}

/* Styling for the span to align properly */
.shape-meditation span {
  display: inline-block;
}
#controls-row {
    border: 1px solid white;
    max-width: 450px;
}
.timing-input label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    margin-bottom: 6px;
    text-align: center;
}
</style>
      
<style>
    /* Action buttons container */
.action-buttons {
  gap: 12px;
  padding: 10px;
  margin: 0 auto;
  width: fit-content;
  background-color: rgba(40, 40, 40, 0.7);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* Individual buttons */
.action-buttons button {
  width: 30px;
  height: 42px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  background-color: rgba(60, 60, 60, 0.8);
  color: #e0e0e0;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Button hover state */
.action-buttons button:hover {
  background-color: rgba(70, 70, 70, 0.9);
  transform: translateY(-2px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  border-color: rgba(255, 255, 255, 0.4);
}

/* Button active state */
.action-buttons button:active {
  transform: translateY(1px);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

off {
  color: #a0aec0;
}

/* Voice button - on state */
.action-buttons button.voice-on {
  color: #4299e1;
  background-color: #ebf8ff;
}

/* Icons within buttons */
.action-buttons button i {
  font-size: 16px;
}
    /* Popup Overlay - positioned over everything */
.popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.65);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  backdrop-filter: blur(5px);
}

/* Popup Container */
.popup {
  background: linear-gradient(145deg, #1f2233, #292d44);
  border-radius: 16px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3),
              0 0 0 1px rgba(255, 255, 255, 0.1);
  width: 90%;
  max-width: 420px;
  padding: 30px;
  text-align: center;
  animation: fadeIn 0.3s ease-out;
  position: relative;
  overflow: hidden;
}

/* Subtle highlight effect */
.popup::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, #5e72e4, #8a5fff);
}

/* Typography */
.popup h2 {
  margin-top: 5px;
  margin-bottom: 20px;
  color: #ffffff;
  font-size: 24px;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.popup p {
  color: #b4b9c8;
  font-size: 15px;
  line-height: 1.5;
  margin-bottom: 25px;
}

/* Input field styling */
.popup input[type="text"] {
  width: 100%;
  padding: 12px 15px;
  background-color: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  color: #ffffff;
  font-size: 15px;
  margin-bottom: 25px;
  transition: all 0.2s ease;
  box-sizing: border-box;
}

.popup input[type="text"]:focus {
  outline: none;
  border-color: #5e72e4;
  box-shadow: 0 0 0 2px rgba(94, 114, 228, 0.3);
  background-color: rgba(255, 255, 255, 0.1);
}

.popup input[type="text"]::placeholder {
  color: #8e94a3;
}

/* Button group */
.button-group {
  display: flex;
  gap: 12px;
  justify-content: center;
}

/* Button styling */
.popup button {
  padding: 12px 20px;
  border-radius: 8px;
  font-size: 15px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  flex: 1;
  max-width: 160px;
}

.save-btn {
  background: linear-gradient(135deg, #5e72e4, #8a5fff);
  color: white;
  box-shadow: 0 4px 12px rgba(94, 114, 228, 0.3);
}

.save-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 15px rgba(94, 114, 228, 0.4);
}

.save-btn:active {
  transform: translateY(1px);
}

.cancel-btn {
  background: rgba(255, 255, 255, 0.08);
  color: #b4b9c8;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.cancel-btn:hover {
  background: rgba(255, 255, 255, 0.12);
  color: #ffffff;
}

/* Animation */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive adjustments */
@media (max-width: 480px) {
  .popup {
    padding: 25px 20px;
  }
  
  .popup h2 {
    font-size: 22px;
  }
  
  .button-group {
    flex-direction: column;
    align-items: center;
  }
  
  .popup button {
    width: 100%;
    max-width: none;
  }
}
    /* Guide container styling - designed for dark backgrounds */
.guide-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(18, 18, 22, 0.85);
  border: 1px solid #4d4dff;
  border-radius: 16px;
  padding: 30px;
  width: 90%;
  max-width: 550px;
  text-align: center;
  box-shadow: 0 0 25px rgba(77, 77, 255, 0.2);
  backdrop-filter: blur(8px);
  z-index: 9999;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
}

/* Heading styles */
.guide-heading {
  font-size: 26px;
  color: #ffffff;
  margin-bottom: 25px;
  font-weight: 500;
  letter-spacing: 0.5px;
  position: relative;
  display: inline-block;
}

.guide-heading::after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: #4d4dff;
}

/* Buttons grid */
.guide-buttons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(125px, 1fr));
  gap: 15px;
  margin-top: 30px;
}

/* Button styles */
.guide-buttons a {
  display: inline-block;
  padding: 12px 15px;
  border-radius: 8px;
  background: #232328;
  color: #ffffff;
  font-weight: 400;
  text-decoration: none;
  transition: all 0.25s ease;
  font-size: 15px;
  border: 1px solid rgba(77, 77, 255, 0.3);
}

.guide-buttons a:hover {
  background: #2a2a30;
  border-color: #4d4dff;
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 20, 0.3);
}

/* Responsive adjustments */
@media (max-width: 550px) {
  .guide-container {
    padding: 25px 20px;
    width: 85%;
  }
  
  .guide-heading {
    font-size: 22px;
  }
  
  .guide-buttons {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }
  
  .guide-buttons a {
    padding: 10px;
    font-size: 14px;
  }
}

/* css for breath section -------------------------------------------------------- */
#breath-option {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 9999;
  background: rgba(15, 15, 15, 0.85);
  backdrop-filter: blur(8px);
  border-radius: 8px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1), 0 0 15px rgba(129, 140, 248, 0.15);
  padding: 16px 20px;
  width: 320px;
  max-width: 90vw;
  border: 1px solid rgba(129, 140, 248, 0.2);
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.control-group > label {
  color: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.2px;
  margin-bottom: 2px;
  text-align: center;
}

.timing-controls {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  gap: 8px;
}

.timing-input {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  min-width: calc(50% - 6px);
  background: rgba(30, 30, 30, 0.6);
  border-radius: 5px;
  padding: 8px;
  transition: all 0.2s ease;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.timing-input:hover {
  background: rgba(40, 40, 40, 0.8);
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
}

.timing-input label {
  color: rgba(255, 255, 255, 0.7);
  font-size: 13px;
  margin-bottom: 6px;
}

.timing-input input {
  background: rgba(20, 20, 20, 0.7);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: white;
  font-size: 13px;
  font-weight: 500;
  padding: 5px 8px;
  width: 60px;
  text-align: center;
  transition: all 0.2s ease;
}

.timing-input input:focus {
  outline: none;
  border-color: rgba(129, 140, 248, 0.7);
  box-shadow: 0 0 0 2px rgba(129, 140, 248, 0.2);
}

.timing-input input:hover {
  border-color: rgba(255, 255, 255, 0.2);
}

/* Hide spinner arrows for number inputs */
.timing-input input::-webkit-outer-spin-button,
.timing-input input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.timing-input input[type=number] {
  -moz-appearance: textfield;
}

/* Add some accent colors for a nice touch */
#inhaleTime, #inhaleTime + label {
  border-color: rgba(129, 140, 248, 0.3);
}

#exhaleTime, #exhaleTime + label {
  border-color: rgba(52, 211, 153, 0.3);
}

#holdInTime, #holdInTime + label, 
#holdOutTime, #holdOutTime + label {
  border-color: rgba(251, 191, 36, 0.3);
}

/* Add subtle glow effect on focus */
.timing-input:focus-within {
  box-shadow: 0 0 12px rgba(255, 255, 255, 0.05);
}

/* Responsive adjustments */
@media (max-width: 480px) {
  #breath-option {
    padding: 16px 18px;
  }
  
  .timing-controls {
    gap: 8px;
  }
  
  .timing-input {
    min-width: calc(50% - 4px);
    padding: 8px;
  }
  
  .timing-input input {
    width: 65px;
    font-size: 13px;
  }
}
select {
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #4b5563; /* dark gray border */
    background-color: #1f2937;  /* dark background */
    font-size: 16px;
    color: #f9fafb;             /* light text */
    width: 100%;
}



</style>  

<!-- Django BAckend data exercise saVE  -->
<script>
    // Store timings during animation
    window.storedTimings = [];
    
    // Function to capture current timings - simplified to just array of values
    function captureCurrentTimings() {
        return [
            parseFloat(document.getElementById('inhaleTime').value) || 4,
            parseFloat(document.getElementById('holdInTime').value) || 4,
            parseFloat(document.getElementById('exhaleTime').value) || 4,
            parseFloat(document.getElementById('holdOutTime').value) || 4
        ];
    }
    
    // Add this function to your code to setup save functionality
    function setupSaveExerciseButton() {
        const saveButton = document.getElementById("saveExerciseButton");
        
        if (saveButton) {
            saveButton.addEventListener("click", saveExercise);
        } else {
            console.error("Save exercise button not found!");
        }
    }
    
    // Separate save function for better organization
    function saveExercise() {
        const nickname = document.getElementById("exerciseNickname").value;
        const shape = shapeSelect.value;
        
        // Store current timings as simple array
        window.storedTimings = captureCurrentTimings();
        
        if (!nickname.trim()) {
            alert("Please enter a nickname for the exercise.");
            return;
        }
        
        // Get CSRF token
        const csrfToken = document.getElementById("csrf_token").value;
        
        fetch("{% url 'breathxapp:save_exercise' %}", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "X-CSRFToken": csrfToken,
            },
            body: new URLSearchParams({
                nickname: nickname,
                shape: shape,
                inputs: JSON.stringify(window.storedTimings), // Convert array to JSON
            }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert("Exercise saved successfully!");
                closePopup(); // Close the popup
            } else {
                alert("Failed to save exercise: " + (data.error || "Unknown error"));
            }
        })
        .catch(error => console.error("Error:", error));
        
        // Automatically simulate clicking the play button when Save is pressed
        const playButton = document.getElementById("playSong");
        if (playButton) playButton.click();
    }
    
    // Function to close popup
    function closePopup() {
        const popup = document.querySelector('.popup-container');
        if (popup) {
            popup.style.display = 'none';
        }
    }
    
    // Add to your initialization function or use the existing DOMContentLoaded
    document.addEventListener("DOMContentLoaded", function() {
        // Add event listener for Save button
        document.getElementById("saveExerciseButton").addEventListener("click", saveExercise);
    });

    </script>
<!-- Buttons Coming gone  -->
<script>
  document.getElementById("breath-close").addEventListener("click", function() {
document.getElementById("breath-option").style.display = "none";
});
// For the save exercise 
const saveButton = document.getElementById("save-exercise-button-id");
const popupOverlay = document.getElementById("popupOverlay");

saveButton.addEventListener("click", () => {
// Toggle visibility
if (popupOverlay.style.display === "none" || popupOverlay.style.display === "") {
popupOverlay.style.display = "flex";
} else {
popupOverlay.style.display = "none";
}
});

function closePopup() {
popupOverlay.style.display = "none";
}
const guideButton = document.getElementById("guide-button-id");
const guideContainer = document.querySelector(".guide-container");

guideButton.addEventListener("click", (e) => {
// Prevent the click event from propagating to the document click event
e.stopPropagation();

// Toggle the visibility of the guide container
guideContainer.style.display =
guideContainer.style.display === "none" || guideContainer.style.display === ""
? "block"
: "none";
});

// Close the guide container when clicking anywhere else on the document
document.addEventListener("click", (e) => {
// Check if the click is outside the guide container or button
if (!guideContainer.contains(e.target) && e.target !== guideButton) {
guideContainer.style.display = "none";  // Hide the guide container
}
});

</script>
<style>

#shapeSelect {
    margin-top: 8px;
    border: 1px solid #454544;
    background: #1e1e1e;
}
#controls-row button {
        border: 1px solid #454544;
}
.shape-meditation {
    color: #ffffff;
}



.main-heading {
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
}

.header-container {
  display: flex;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
}

.back-button {
  background: transparent;
  border: none;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  margin-right: 15px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.title {
  color: white;
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.meditation-area {
    margin-bottom: 20px;

}
@media screen and (max-width: 668px) {
.guide-container-end{
  display: block;
}
}
#vibration-button-set {
  position: relative;
}

#vibration-button-set::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 60%;
  height: 3px;
  background-color: #ff4444;
  transform: translate(-50%, -50%) rotate(45deg);
  opacity: 0;
  transition: opacity 0.3s ease;
}

#vibration-button-set.off::after {
  opacity: 1;
}

#vibration-button-set.off img {
  filter: grayscale(100%) opacity(0.5);
}


.action-buttons {
    gap: 5%;
    padding: 10px;
    margin: 0 auto;
    width: 100%;
    background-color: #121212;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}
#controls-row {
    border: 1px solid white;
    max-width: 450px;
    gap: 30px;
}
#controls-row {
    border: 1px solid #302e2e;
    max-width: 450px;
    gap: 30px;
}

.action-buttons {
    gap: 12%;
    padding: 10px;
    margin: 0 auto;
    width: 100%;
    background-color: #000000;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    margin-top: -40px;
    border-left: 1px solid #302e2e;
    border-right: 1px solid #302e2e;
    border-bottom: 1px solid #302e2e;
    max-width: 450px;
}

</style>

<style>
@media screen and (min-width: 700px) {
  #leave-group-session {
    margin-top: 10px;
  }
}
#shapeSelect {
    margin-top: 8px;
    border: 1px solid #454544;
    background: #1e1e1e;
}
#controls-row button {
        border: 1px solid #454544;
}
.shape-meditation {
    color: #ffffff;
}



.main-heading {
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
}

.header-container {
  display: flex;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
}

.back-button {
  background: transparent;
  border: none;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  margin-right: 15px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.title {
  color: white;
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.meditation-area {
    margin-bottom: 20px;

}
@media screen and (max-width: 668px) {
.guide-container-end{
  display: block;
}
}
#vibration-button-set {
  position: relative;
}

#vibration-button-set::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 60%;
  height: 3px;
  background-color: #ff4444;
  transform: translate(-50%, -50%) rotate(45deg);
  opacity: 0;
  transition: opacity 0.3s ease;
}

#vibration-button-set.off::after {
  opacity: 1;
}

#vibration-button-set.off img {
  filter: grayscale(100%) opacity(0.5);
}


.action-buttons {
    gap: 5%;
    padding: 10px;
    margin: 0 auto;
    width: 100%;
    background-color: #121212;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}
#controls-row {
    border: 1px solid white;
    max-width: 450px;
    gap: 30px;
}
#controls-row {
    border: 1px solid #302e2e;
    max-width: 450px;
    gap: 30px;
}

.action-buttons {
    gap: 12%;
    padding: 10px;
    margin: 0 auto;
    width: 100%;
    background-color: #000000;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    margin-top: -40px;
    border-left: 1px solid #302e2e;
    border-right: 1px solid #302e2e;
    border-bottom: 1px solid #302e2e;
    max-width: 450px;
}

  #controls-row button {
    margin-right: 22px;
  }
  @media (max-width: 500px) {
    #breathstartbtn {
      display: flex;
      padding: 0;
      margin: 0;
      width: 100vw;
      gap: 12px;
    }
 #controls-row button {
    margin-right: 0px;
  }
    #breathtoggleBtn,
    #startButton {
      flex: 1;
      margin: 0;
      padding: 0;
      border: none;
      box-sizing: border-box;
    }
        .control-group {
        margin-bottom: 5px;
    }
.action-buttons button {
    width: 42px;
    height: 42px;
}

  }
  @media (max-width: 430px) {

  #controls-row {
    border: 1px solid #302e2e;
    max-width: 372px;
    gap: 30px;
}
  }

  @media (max-width: 350px) {

  #controls-row {
    border: 1px solid #302e2e;
    max-width: 320px;
    gap: 30px;
}
  }
</style>
    <!-- For activity Page ----------------------------------------------- -->
     <script>
    let startTime = Date.now();

    window.addEventListener("beforeunload", function () {
        let duration = Math.round((Date.now() - startTime) / 1000);

        navigator.sendBeacon("/activityapp/track-activity/", JSON.stringify({
            url: window.location.pathname,
            duration: duration
        }));
    });
</script>









<!-- Custom Popup -->
<div id="leave-popup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
background-color: #1e1e1e; color: white; width: 95%; max-width: 400px; padding: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 10px; text-align: center; z-index: 999;">
  <p style="margin-bottom: 20px; font-weight: 500;">Breathe — do you really want to leave?</p>
  <div style="display: flex; justify-content: space-between;">
    <button onclick="window.location.href='{% url 'home' %}'" style="flex: 1; background-color: #e63946; color: white; border: none; padding: 10px 0; border-radius: 6px; margin-right: 10px; cursor: pointer;">Yes</button>
    <button onclick="document.getElementById('leave-popup').style.display='none'" style="flex: 1; background-color: #444; color: white; border: none; padding: 10px 0; border-radius: 6px; cursor: pointer;">Cancel</button>
  </div>
</div>

<!-- Script -->
<script>
  document.getElementById('leave-group-session').onclick = function () {
    document.getElementById('leave-popup').style.display = 'block';
  };
</script>           
<!-- Code for real time communication    -->
 
<script>
  // Enhanced real-time synchronization script for breathing exercise with connection status
(function() {
    'use strict';
    
    // WebSocket connection variables
    let socket;
    let isLeader = false;
    let isConnected = false;
    let connectionStartTime = null;
    let connectionTimer = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let reconnectDelay = 3000;
    
    // Get chatroom name from current URL or set it
    const chatroomName = '{{ chatroom.name }}' || window.location.pathname.split('/').pop() || 'default';
    const isAuthenticated = {{ request.user.is_authenticated|yesno:"true,false" }};
    const isMember = {{ is_member|yesno:"true,false" }};
    
    // Create connection status UI
    function createConnectionStatusUI() {
        // Remove existing status UI if any
        const existingStatus = document.getElementById('websocket-status');
        if (existingStatus) {
            existingStatus.remove();
        }
        
        // Create status container
        const statusContainer = document.createElement('div');
        statusContainer.id = 'websocket-status';
        statusContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #121212;
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 10000;
            font-size: 14px;
            min-width: 250px;
            transition: all 0.3s ease;
        `;
        
        // Create status text
        const statusText = document.createElement('div');
        statusText.id = 'connection-status-text';
        statusText.style.marginBottom = '10px';
        
        // Create timer display
        const timerDisplay = document.createElement('div');
        timerDisplay.id = 'connection-timer';
        timerDisplay.style.cssText = `
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
        `;
        
        // Create test connection button
        const testButton = document.createElement('button');
        testButton.id = 'test-connection-btn';
        testButton.textContent = 'Test Connection';
        testButton.style.cssText = `
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 12px;
        `;
        
        // Create force reconnect button
        const reconnectButton = document.createElement('button');
        reconnectButton.id = 'force-reconnect-btn';
        reconnectButton.textContent = 'Force Reconnect';
        reconnectButton.style.cssText = `
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        `;
        
        // Create minimize button
        const minimizeButton = document.createElement('button');
        minimizeButton.id = 'minimize-status-btn';
        minimizeButton.textContent = '−';
        minimizeButton.style.cssText = `
                    position: absolute;
                top: 8px;
                right: 8px;
                background: rgba(255, 255, 255, 0.2);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
        `;
        
        // Assemble the UI
        statusContainer.appendChild(minimizeButton);
        statusContainer.appendChild(statusText);
        statusContainer.appendChild(timerDisplay);
        statusContainer.appendChild(testButton);
        statusContainer.appendChild(reconnectButton);
        
        document.body.appendChild(statusContainer);
        
        // Add event listeners
        testButton.addEventListener('click', testConnection);
        reconnectButton.addEventListener('click', forceReconnect);
        minimizeButton.addEventListener('click', toggleStatusUI);
        
        return {
            container: statusContainer,
            statusText: statusText,
            timerDisplay: timerDisplay,
            testButton: testButton,
            reconnectButton: reconnectButton
        };
    }
    
    // Toggle status UI visibility
    function toggleStatusUI() {
        const container = document.getElementById('websocket-status');
        const minimizeBtn = document.getElementById('minimize-status-btn');
        
        if (container.style.height === '35px') {
            // Expand
            container.style.height = 'auto';
            container.style.overflow = 'visible';
            minimizeBtn.textContent = '-';
            container.querySelectorAll('div:not(.role-indicator), button:not(#minimize-status-btn)').forEach((el) => {
                el.style.display = 'block';
            });
        } else {
            // Minimize
            container.style.height = '35px';
            container.style.overflow = 'hidden';
            minimizeBtn.textContent = '+';
            container.querySelectorAll('div:not(.role-indicator), button:not(#minimize-status-btn)').forEach((el) => {
                el.style.display = 'none';
            });
        }
    }
    
    // Update connection status display
    function updateConnectionStatus(status, color = '#ffffff') {
        const statusText = document.getElementById('connection-status-text');
        if (statusText) {
            statusText.textContent = status;
            statusText.style.color = color;
        }
        console.log('Connection Status:', status);
    }
    
    // Update connection timer
    function updateConnectionTimer() {
        const timerDisplay = document.getElementById('connection-timer');
        if (!timerDisplay || !connectionStartTime) return;
        
        const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
        
        if (!isConnected) {
            timerDisplay.textContent = `Connecting... ${elapsed}s`;
            timerDisplay.style.color = '#ffd700';
        } else {
            timerDisplay.textContent = `Connected in ${elapsed}s`;
            timerDisplay.style.color = '#28a745';
            // Clear timer after showing success for 3 seconds
            setTimeout(() => {
                if (timerDisplay) {
                    timerDisplay.textContent = '';
                }
            }, 3000);
        }
    }
    
    // Start connection timer
    function startConnectionTimer() {
        connectionStartTime = Date.now();
        connectionTimer = setInterval(updateConnectionTimer, 1000);
    }
    
    // Stop connection timer
    function stopConnectionTimer() {
        if (connectionTimer) {
            clearInterval(connectionTimer);
            connectionTimer = null;
        }
    }
    
    // Test connection function
    function testConnection() {
        const testButton = document.getElementById('test-connection-btn');
        const originalText = testButton.textContent;
        
        testButton.textContent = 'Testing...';
        testButton.disabled = true;
        
        if (!isConnected) {
            updateConnectionStatus('❌ Not Connected', '#dc3545');
        } else {
            // Send a test message
            sendMessage({
                type: 'connection_test',
                timestamp: Date.now()
            });
            updateConnectionStatus('✅ Connected & Active', '#28a745');
        }
        
        setTimeout(() => {
            testButton.textContent = originalText;
            testButton.disabled = false;
        }, 2000);
    }
    
    // Force reconnect function
    function forceReconnect() {
        const reconnectButton = document.getElementById('force-reconnect-btn');
        const originalText = reconnectButton.textContent;
        
        reconnectButton.textContent = 'Reconnecting...';
        reconnectButton.disabled = true;
        
        updateConnectionStatus('🔄 Force Reconnecting...', '#ffd700');
        
        // Close existing connection
        if (socket) {
            socket.close();
        }
        
        // Reset connection state
        isConnected = false;
        reconnectAttempts = 0;
        
        // Start new connection after brief delay
        setTimeout(() => {
            initializeWebSocket();
            reconnectButton.textContent = originalText;
            reconnectButton.disabled = false;
        }, 1000);
    }
    
    // Initialize WebSocket connection
    function initializeWebSocket() {
        if (!isAuthenticated || !isMember) {
            updateConnectionStatus('❌ Not Authenticated', '#dc3545');
            console.log('User not authenticated or not a member');
            return;
        }
        
        // Start connection timer
        startConnectionTimer();
        updateConnectionStatus('🔄 Connecting...', '#ffd700');
        
        const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
        const wsUrl = wsScheme + '://' + window.location.host + '/ws/chatroom/' + chatroomName + '/';
        
        console.log('Attempting WebSocket connection to:', wsUrl);
        
        try {
            socket = new WebSocket(wsUrl);
            
            // Set connection timeout
            const connectionTimeout = setTimeout(() => {
                if (!isConnected) {
                    updateConnectionStatus('⏰ Connection Timeout', '#dc3545');
                    socket.close();
                }
            }, 15000); // 15 second timeout
            
            socket.onopen = function(e) {
                console.log('WebSocket connected for real-time sync');
                clearTimeout(connectionTimeout);
                isConnected = true;
                reconnectAttempts = 0;
                updateConnectionStatus('✅ Connected Successfully', '#28a745');
                stopConnectionTimer();
                updateConnectionTimer(); // Show final connection time
                
                // Send initial connection message
                sendMessage({
                    type: 'user_connected',
                    timestamp: Date.now()
                });
            };
            
            socket.onmessage = function(e) {
                try {
                    const data = JSON.parse(e.data);
                    handleIncomingMessage(data);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };
            
            socket.onclose = function(e) {
                console.log('WebSocket disconnected. Code:', e.code, 'Reason:', e.reason);
                clearTimeout(connectionTimeout);
                isConnected = false;
                stopConnectionTimer();
                
                if (e.code === 1000) {
                    updateConnectionStatus('✅ Connection Closed Normally', '#28a745');
                } else {
                    updateConnectionStatus(`❌ Connection Lost (${e.code})`, '#dc3545');
                    
                    // Auto-reconnect with exponential backoff
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = reconnectDelay * Math.pow(2, reconnectAttempts - 1);
                        updateConnectionStatus(`🔄 Reconnecting in ${Math.ceil(delay/1000)}s (${reconnectAttempts}/${maxReconnectAttempts})`, '#ffd700');
                        
                        setTimeout(() => {
                            if (!isConnected) {
                                initializeWebSocket();
                            }
                        }, delay);
                    } else {
                        updateConnectionStatus('❌ Max Reconnect Attempts Reached', '#dc3545');
                    }
                }
            };
            
            socket.onerror = function(e) {
                console.error('WebSocket error:', e);
                updateConnectionStatus('❌ Connection Error', '#dc3545');
            };
            
        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            updateConnectionStatus('❌ Connection Failed', '#dc3545');
            stopConnectionTimer();
        }
    }
    
    // Handle incoming WebSocket messages
    function handleIncomingMessage(data) {
        if (!data.type) return;
        
        console.log('Received message:', data.type);
        
        switch(data.type) {
            case 'user_role':
                isLeader = data.is_leader;
                updateUIForRole();
                break;
                
            case 'connection_test':
                // Respond to connection test
                sendMessage({
                    type: 'connection_test_response',
                    timestamp: Date.now()
                });
                break;
                
            case 'connection_test_response':
                updateConnectionStatus('✅ Connection Test Passed', '#28a745');
                break;
                
            case 'shape_change':
                if (!isLeader) {
                    updateShapeSelection(data.shape);
                }
                break;
                
            case 'breath_toggle':
                if (!isLeader) {
                    handleBreathToggle(data.isActive);
                }
                break;
                
            case 'exercise_start':
                if (!isLeader) {
                    handleExerciseStart();
                }
                break;
                
            case 'voice_toggle':
                if (!isLeader) {
                    handleVoiceToggle(data.isActive);
                }
                break;
                
            case 'vibration_toggle':
                if (!isLeader) {
                    handleVibrationToggle(data.isActive);
                }
                break;
                
            case 'save_exercise':
                if (!isLeader) {
                    handleSaveExercise();
                }
                break;
                
            case 'show_guide':
                if (!isLeader) {
                    handleShowGuide();
                }
                break;
                
            case 'breathing_timing_change':
                if (!isLeader) {
                    handleBreathingTimingChange(data);
                }
                break;
                
            case 'close_component':
                if (!isLeader) {
                    handleCloseComponent(data.componentId);
                }
                break;
                
            case 'reload_all':
                handleReloadAll(data);
                break;
        }
    }
    
    // Send message through WebSocket
    function sendMessage(messageData) {
        if (socket && socket.readyState === WebSocket.OPEN) {
            // Allow connection test messages from anyone
            if (messageData.type === 'connection_test' || messageData.type === 'connection_test_response' || messageData.type === 'user_connected') {
                socket.send(JSON.stringify(messageData));
                return;
            }
            
            // Other messages only from leader
            if (isLeader) {
                socket.send(JSON.stringify(messageData));
            }
        } else {
            console.warn('Cannot send message - WebSocket not connected');
            updateConnectionStatus('❌ Cannot Send - Not Connected', '#dc3545');
        }
    }
    
    // Update UI based on user role
    function updateUIForRole() {
        const statusContainer = document.getElementById('websocket-status');
        if (statusContainer) {
            const roleIndicator = statusContainer.querySelector('.role-indicator') || document.createElement('div');
            roleIndicator.className = 'role-indicator';
            roleIndicator.style.cssText = `
                font-weight: bold;
                margin-bottom: 10px;
                padding: 5px 10px;
                border-radius: 5px;
                text-align: center;
            `;
            
            if (isLeader) {
                roleIndicator.textContent = '👑 LEADER';
                roleIndicator.style.background = '#28a745';
                roleIndicator.style.color = 'white';
            } else {
                roleIndicator.textContent = '👥 FOLLOWER';
                roleIndicator.style.background = '#6c757d';
                roleIndicator.style.color = 'white';
            }
            
            if (!statusContainer.querySelector('.role-indicator')) {
                statusContainer.insertBefore(roleIndicator, statusContainer.firstChild.nextSibling);
            }
        }
        
        if (!isLeader) {
            // Add visual indicator for followers in the main UI
            const controls = document.getElementById('controls-row');
            if (controls && !controls.querySelector('.follower-indicator')) {
                const indicator = document.createElement('div');
                indicator.className = 'follower-indicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 255, 255, 0.9);
                    color: #333;
                    padding: 5px 10px;
                    border-radius: 15px;
                    font-size: 12px;
                    font-weight: bold;
                `;
                indicator.textContent = '👥 Following Leader';
                controls.style.position = 'relative';
                controls.appendChild(indicator);
            }
        }
    }
    
    // Handle shape selection updates
    function updateShapeSelection(shape) {
        const shapeSelect = document.getElementById('shapeSelect');
        if (shapeSelect && shapeSelect.value !== shape) {
            shapeSelect.value = shape;
            shapeSelect.dispatchEvent(new Event('change'));
        }
    }
    
    // Handle breath toggle
    function handleBreathToggle(isActive) {
        const breathBtn = document.getElementById('breathtoggleBtn');
        if (breathBtn) {
            breathBtn.click();
        }
    }
    
    // Handle exercise start
    function handleExerciseStart() {
        const startBtn = document.getElementById('startButton');
        if (startBtn) {
            startBtn.click();
        }
    }
    
    // Handle voice toggle
    function handleVoiceToggle(isActive) {
        const voiceBtn = document.getElementById('voice-start');
        if (voiceBtn) {
            voiceBtn.click();
        }
    }
    
    // Handle vibration toggle
    function handleVibrationToggle(isActive) {
        const vibrationBtn = document.getElementById('vibration-button-set');
        if (vibrationBtn) {
            vibrationBtn.click();
        }
    }
    
    // Handle save exercise
    function handleSaveExercise() {
        const saveBtn = document.getElementById('save-exercise-button-id');
        if (saveBtn) {
            saveBtn.click();
        }
    }
    
    // Handle show guide
    function handleShowGuide() {
        const guideBtn = document.getElementById('guide-button-id');
        if (guideBtn) {
            guideBtn.click();
        }
    }
    
    // Handle close component
    function handleCloseComponent(componentId) {
        console.log('Follower received close command for:', componentId);
        
        const component = document.getElementById(componentId);
        if (component) {
            if (component.tagName === 'BUTTON') {
                component.click();
                return;
            }
            
            component.style.display = 'none';
            
            let parent = component.parentElement;
            while (parent) {
                if (parent.classList.contains('modal') || 
                    parent.classList.contains('popup') || 
                    parent.classList.contains('overlay') ||
                    parent.classList.contains('dialog')) {
                    parent.style.display = 'none';
                    break;
                }
                parent = parent.parentElement;
            }
            
            const activeClasses = ['active', 'open', 'show', 'visible'];
            activeClasses.forEach(className => {
                if (component.classList.contains(className)) {
                    component.classList.remove(className);
                }
                
                let parentEl = component.parentElement;
                while (parentEl) {
                    if (parentEl.classList.contains(className)) {
                        parentEl.classList.remove(className);
                    }
                    parentEl = parentEl.parentElement;
                }
            });
            
            component.dispatchEvent(new Event('close', { bubbles: true }));
            component.dispatchEvent(new CustomEvent('component-close', { 
                bubbles: true, 
                detail: { componentId: componentId } 
            }));
        }
    }
    
    // Handle reload all functionality
    function handleReloadAll(data) {
        console.log('Received reload all command from leader:', data.leader);
        
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
            font-size: 16px;
            text-align: center;
        `;
        notification.textContent = `Leader ${data.leader} is reconnecting with you...`;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);
    }
    
    // Handle breathing timing changes
    function handleBreathingTimingChange(data) {
        const { inhaleTime, holdInTime, exhaleTime, holdOutTime } = data;
        
        console.log('Follower received timing change:', data);
        
        const inhaleSelect = document.getElementById('inhaleTime');
        const holdInSelect = document.getElementById('holdInTime');
        const exhaleSelect = document.getElementById('exhaleTime');
        const holdOutSelect = document.getElementById('holdOutTime');
        
        const originalIsLeader = isLeader;
        isLeader = true;
        
        if (inhaleSelect && inhaleTime !== undefined) {
            inhaleSelect.value = inhaleTime;
        }
        if (holdInSelect && holdInTime !== undefined) {
            holdInSelect.value = holdInTime;
        }
        if (exhaleSelect && exhaleTime !== undefined) {
            exhaleSelect.value = exhaleTime;
        }
        if (holdOutSelect && holdOutTime !== undefined) {
            holdOutSelect.value = holdOutTime;
        }
        
        setTimeout(() => {
            [inhaleSelect, holdInSelect, exhaleSelect, holdOutSelect].forEach((select) => {
                if (select) {
                    select.dispatchEvent(new Event('change', { bubbles: true }));
                    select.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
            
            if (window.$ || window.jQuery) {
                const $ = window.$ || window.jQuery;
                $('#inhaleTime, #holdInTime, #exhaleTime, #holdOutTime').trigger('change');
            }
            
            const timingValues = {
                inhale: parseInt(inhaleTime) || 4,
                holdIn: parseInt(holdInTime) || 4,
                exhale: parseInt(exhaleTime) || 4,
                holdOut: parseInt(holdOutTime) || 4
            };
            
            const updateFunctions = [
                'updateBreathingTiming',
                'updateTiming',
                'setBreathingTiming',
                'changeBreathingTiming',
                'applyBreathingTiming'
            ];
            
            updateFunctions.forEach(funcName => {
                if (window[funcName] && typeof window[funcName] === 'function') {
                    try {
                        window[funcName](timingValues);
                    } catch (e) {
                        console.log(`Error calling ${funcName}:`, e);
                    }
                }
            });
            
            const globalVars = ['breathingTimer', 'breathingConfig', 'breathConfig', 'timing'];
            globalVars.forEach(varName => {
                if (window[varName]) {
                    Object.assign(window[varName], timingValues);
                }
            });
            
            if (window.initializeBreathing && typeof window.initializeBreathing === 'function') {
                window.initializeBreathing();
            }
            
            if (window.breathingAnimation || window.animation) {
                const anim = window.breathingAnimation || window.animation;
                if (anim && typeof anim === 'object') {
                    Object.assign(anim, timingValues);
                }
            }
            
            isLeader = originalIsLeader;
        }, 100);
        
        setTimeout(() => {
            if (window.restartBreathing && typeof window.restartBreathing === 'function') {
                window.restartBreathing();
            }
            
            const timingControls = document.querySelectorAll('#inhaleTime, #holdInTime, #exhaleTime, #holdOutTime');
            timingControls.forEach(control => {
                if (control) {
                    control.focus();
                    control.blur();
                }
            });
        }, 300);
    }
    
    // Set up event listeners for leader controls
    function setupLeaderControls() {
        const shapeSelect = document.getElementById('shapeSelect');
        if (shapeSelect) {
            shapeSelect.addEventListener('change', function() {
                sendMessage({
                    type: 'shape_change',
                    shape: this.value
                });
            });
        }
        
        const breathBtn = document.getElementById('breathtoggleBtn');
        if (breathBtn) {
            breathBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'breath_toggle',
                    isActive: true
                });
            });
        }
        
        const startBtn = document.getElementById('startButton');
        if (startBtn) {
            startBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'exercise_start'
                });
            });
        }
        
        const voiceBtn = document.getElementById('voice-start');
        if (voiceBtn) {
            voiceBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'voice_toggle',
                    isActive: !this.classList.contains('voice-off')
                });
            });
        }
        
        const vibrationBtn = document.getElementById('vibration-button-set');
        if (vibrationBtn) {
            vibrationBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'vibration_toggle',
                    isActive: true
                });
            });
        }
        
        const saveBtn = document.getElementById('save-exercise-button-id');
        if (saveBtn) {
            saveBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'save_exercise'
                });
            });
        }
        
        const guideBtn = document.getElementById('guide-button-id');
        if (guideBtn) {
            guideBtn.addEventListener('click', function() {
                sendMessage({
                    type: 'show_guide'
                });
            });
        }
        
        const reloadAllBtn = document.getElementById('reload-all');
        if (reloadAllBtn) {
            reloadAllBtn.addEventListener('click', function() {
                if (confirm('This will reconnect with all users but existing exercise will be stopped. Continue?')) {
                    sendMessage({
                        type: 'reload_all',
                        leader: 'Admin'
                    });
                    
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                }
            });
        }
        
        setupBreathingTimingControls();
        setupCloseButtonControls();
    }
    
    // Set up breathing timing control listeners
    function setupBreathingTimingControls() {
        const timingSelects = ['inhaleTime', 'holdInTime', 'exhaleTime', 'holdOutTime'];
        
        timingSelects.forEach(selectId => {
            const select = document.getElementById(selectId);
            if (select) {
                select.addEventListener('change', function() {
                    if (!isLeader) {
                        return;
                    }
                    
                    const inhaleTime = document.getElementById('inhaleTime')?.value;
                    const holdInTime = document.getElementById('holdInTime')?.value;
                    const exhaleTime = document.getElementById('exhaleTime')?.value;
                    const holdOutTime = document.getElementById('holdOutTime')?.value;
                    
                    const message = {
                        type: 'breathing_timing_change',
                        inhaleTime: inhaleTime,
                        holdInTime: holdInTime,
                        exhaleTime: exhaleTime,
                        holdOutTime: holdOutTime
                    };
                    
                    sendMessage(message);
                });
            }
        });
    }
    
    // Set up close button control listeners
    function setupCloseButtonControls() {
        const closeButtonSelectors = [
            '#breath-close',
            '#close-button',
            '#modal-close',
            '#popup-close',
            '#dialog-close',
            '.close-btn',
            '.modal-close',
            '.popup-close',
            '[data-dismiss]',
            '[data-close]'
        ];
        
        closeButtonSelectors.forEach(selector => {
            document.addEventListener('click', function(e) {
                if (!isLeader) return;
                
                const target = e.target;
                
                if (target.matches && target.matches(selector)) {
                    const componentId = target.id || target.getAttribute('data-close') || selector.replace('#', '');
                    
                    sendMessage({
                        type: 'close_component',
                        componentId: componentId
                    });
                }
            });
        });
        
        document.addEventListener('keydown', function(e) {
            if (!isLeader) return;
            
            if (e.key === 'Escape' || e.keyCode === 27) {
                const openElements = document.querySelectorAll('.modal.show, .popup.open, .dialog.active, [style*="display: block"]');
                openElements.forEach(element => {
                    if (element.id) {
                        sendMessage({
                            type: 'close_component',
                            componentId: element.id
                        });
                    }
                });
            }
        });
    }
    
    // Initialize everything when DOM is loaded
    function initialize() {
        // Create connection status UI first
        createConnectionStatusUI();
        
        // Initialize WebSocket
        initializeWebSocket();
        
        // Set up leader controls after getting role
        setTimeout(() => {
            if (isLeader) {
                setupLeaderControls();
            }
        }, 2000); // Increased delay to ensure connection is established
    }
    
    // Handle page visibility changes
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && (!socket || socket.readyState === WebSocket.CLOSED)) {
            updateConnectionStatus('🔄 Page Visible - Reconnecting...', '#ffd700');
            initializeWebSocket();
        }
    });
    
    // Handle page unload
    window.addEventListener('beforeunload', function() {
        if (socket) {
            socket.close(1000, 'Page unloading');
        }
    });
    
    // Handle network status changes
    window.addEventListener('online', function() {
        updateConnectionStatus('🌐 Network Online - Reconnecting...', '#28a745');
        if (!isConnected) {
            setTimeout(initializeWebSocket, 1000);
        }
    });
    
    window.addEventListener('offline', function() {
        updateConnectionStatus('🌐 Network Offline', '#dc3545');
    });
    
    // Periodic connection health check
    function startHealthCheck() {
        setInterval(() => {
            if (isConnected && socket && socket.readyState === WebSocket.OPEN) {
                // Send ping to check if connection is really alive
                sendMessage({
                    type: 'ping',
                    timestamp: Date.now()
                });
            } else if (!isConnected && (!socket || socket.readyState === WebSocket.CLOSED)) {
                // Try to reconnect if disconnected for too long
                updateConnectionStatus('🔄 Auto-reconnecting...', '#ffd700');
                initializeWebSocket();
            }
        }, 30000); // Check every 30 seconds
    }
    
    // Start initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
    
    // Start health check after initial setup
    setTimeout(startHealthCheck, 5000);
    
})();
</script>

<!-- This is new trial  -->
<!-- 
<script>
// Enhanced Real-time synchronization script for breathing exercise
(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        RECONNECT_DELAY: 3000,
        HEARTBEAT_INTERVAL: 30000,
        MAX_RECONNECT_ATTEMPTS: 10,
        READY_CHECK_INTERVAL: 500,
        READY_CHECK_TIMEOUT: 15000,
        CONNECTION_STATUS_DISPLAY_TIME: 3000
    };
    
    // State management
    const state = {
        socket: null,
        isLeader: false,
        isConnected: false,
        isReady: false,
        reconnectAttempts: 0,
        heartbeatInterval: null,
        readyCheckInterval: null,
        lastHeartbeat: null,
        connectionStatus: 'disconnected', // disconnected, connecting, connected, ready
        pendingOperations: []
    };
    
    // Get chatroom configuration
    const chatroomName = '{{ chatroom.name }}' || window.location.pathname.split('/').pop() || 'default';
    const isAuthenticated = {{ request.user.is_authenticated|yesno:"true,false" }};
    const isMember = {{ is_member|yesno:"true,false" }};
    const userName = '{{ request.user.username }}' || 'Anonymous';
    
    // DOM Elements cache
    const elements = {};
    
    // Utility functions
    function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] [${type.toUpperCase()}] Breathing Sync:`, message);
    }
    
    function showConnectionStatus(message, type = 'info') {
        // Remove existing status indicator
        const existing = document.getElementById('sync-status-indicator');
        if (existing) existing.remove();
        
        // Create new status indicator
        const indicator = document.createElement('div');
        indicator.id = 'sync-status-indicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            transition: all 0.3s ease;
            ${type === 'success' ? 'background: #4CAF50; color: white;' : ''}
            ${type === 'warning' ? 'background: #FF9800; color: white;' : ''}
            ${type === 'error' ? 'background: #F44336; color: white;' : ''}
            ${type === 'info' ? 'background: #2196F3; color: white;' : ''}
        `;
        indicator.textContent = message;
        document.body.appendChild(indicator);
        
        // Auto remove after delay
        setTimeout(() => {
            if (indicator.parentNode) {
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }
        }, CONFIG.CONNECTION_STATUS_DISPLAY_TIME);
    }
    
    function cacheElements() {
        const elementIds = [
            'shapeSelect', 'breathtoggleBtn', 'startButton', 'voice-start',
            'vibration-button-set', 'save-exercise-button-id', 'guide-button-id',
            'reload-all', 'inhaleTime', 'holdInTime', 'exhaleTime', 'holdOutTime',
            'controls-row'
        ];
        
        elementIds.forEach(id => {
            elements[id] = document.getElementById(id);
        });
        
        log(`Cached ${Object.keys(elements).filter(key => elements[key]).length} elements`);
    }
    
    function waitForElement(selector, timeout = 5000) {
        return new Promise((resolve, reject) => {
            const element = document.querySelector(selector);
            if (element) {
                resolve(element);
                return;
            }
            
            const observer = new MutationObserver((mutations, obs) => {
                const element = document.querySelector(selector);
                if (element) {
                    obs.disconnect();
                    resolve(element);
                }
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            setTimeout(() => {
                observer.disconnect();
                reject(new Error(`Element ${selector} not found within ${timeout}ms`));
            }, timeout);
        });
    }
    
    // WebSocket management
    function initializeWebSocket() {
        if (!isAuthenticated || !isMember) {
            log('User not authenticated or not a member', 'warning');
            showConnectionStatus('Not authorized for sync', 'warning');
            return;
        }
        
        if (state.socket && state.socket.readyState === WebSocket.OPEN) {
            log('WebSocket already connected');
            return;
        }
        
        state.connectionStatus = 'connecting';
        showConnectionStatus('Connecting to sync server...', 'info');
        
        const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
        const wsUrl = `${wsScheme}://${window.location.host}/ws/chatroom/${chatroomName}/`;
        
        log(`Connecting to: ${wsUrl}`);
        
        try {
            state.socket = new WebSocket(wsUrl);
            
            state.socket.onopen = handleWebSocketOpen;
            state.socket.onmessage = handleWebSocketMessage;
            state.socket.onclose = handleWebSocketClose;
            state.socket.onerror = handleWebSocketError;
            
        } catch (error) {
            log(`WebSocket connection error: ${error.message}`, 'error');
            scheduleReconnect();
        }
    }
    
    function handleWebSocketOpen(e) {
        log('WebSocket connected successfully');
        state.isConnected = true;
        state.connectionStatus = 'connected';
        state.reconnectAttempts = 0;
        
        showConnectionStatus('Connected! Synchronizing...', 'success');
        
        // Send ready signal
        sendMessage({
            type: 'user_ready',
            username: userName,
            timestamp: Date.now()
        });
        
        // Start heartbeat
        startHeartbeat();
        
        // Process any pending operations
        processPendingOperations();
        
        // Request current state
        setTimeout(() => {
            sendMessage({
                type: 'request_current_state'
            });
        }, 500);
    }
    
    function handleWebSocketMessage(e) {
        try {
            const data = JSON.parse(e.data);
            log(`Received message: ${data.type}`);
            
            // Update last heartbeat time
            state.lastHeartbeat = Date.now();
            
            handleIncomingMessage(data);
            
        } catch (error) {
            log(`Error parsing message: ${error.message}`, 'error');
        }
    }
    
    function handleWebSocketClose(e) {
        log(`WebSocket disconnected: ${e.code} - ${e.reason}`);
        state.isConnected = false;
        state.isReady = false;
        state.connectionStatus = 'disconnected';
        
        stopHeartbeat();
        
        if (e.code !== 1000) { // Not a normal closure
            showConnectionStatus('Connection lost. Reconnecting...', 'warning');
            scheduleReconnect();
        }
    }
    
    function handleWebSocketError(e) {
        log(`WebSocket error: ${e}`, 'error');
        showConnectionStatus('Connection error. Retrying...', 'error');
    }
    
    function scheduleReconnect() {
        if (state.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
            log('Max reconnection attempts reached', 'error');
            showConnectionStatus('Unable to connect. Please refresh the page.', 'error');
            return;
        }
        
        state.reconnectAttempts++;
        log(`Scheduling reconnect attempt ${state.reconnectAttempts} in ${CONFIG.RECONNECT_DELAY}ms`);
        
        setTimeout(() => {
            if (state.connectionStatus === 'disconnected') {
                initializeWebSocket();
            }
        }, CONFIG.RECONNECT_DELAY);
    }
    
    function startHeartbeat() {
        stopHeartbeat();
        state.lastHeartbeat = Date.now();
        
        state.heartbeatInterval = setInterval(() => {
            if (state.isConnected) {
                sendMessage({ type: 'heartbeat', timestamp: Date.now() });
                
                // Check if we've received a recent heartbeat response
                if (Date.now() - state.lastHeartbeat > CONFIG.HEARTBEAT_INTERVAL * 2) {
                    log('Heartbeat timeout, reconnecting', 'warning');
                    state.socket?.close();
                }
            }
        }, CONFIG.HEARTBEAT_INTERVAL);
    }
    
    function stopHeartbeat() {
        if (state.heartbeatInterval) {
            clearInterval(state.heartbeatInterval);
            state.heartbeatInterval = null;
        }
    }
    
    // Message handling
    function sendMessage(messageData) {
        if (!state.socket || state.socket.readyState !== WebSocket.OPEN) {
            log('WebSocket not ready, queueing message');
            state.pendingOperations.push(messageData);
            return false;
        }
        
        if (!state.isLeader && !['user_ready', 'request_current_state', 'heartbeat'].includes(messageData.type)) {
            log('Follower cannot send control messages', 'warning');
            return false;
        }
        
        try {
            state.socket.send(JSON.stringify(messageData));
            log(`Sent message: ${messageData.type}`);
            return true;
        } catch (error) {
            log(`Error sending message: ${error.message}`, 'error');
            return false;
        }
    }
    
    function processPendingOperations() {
        if (state.pendingOperations.length === 0) return;
        
        log(`Processing ${state.pendingOperations.length} pending operations`);
        
        const operations = [...state.pendingOperations];
        state.pendingOperations = [];
        
        operations.forEach(operation => {
            setTimeout(() => sendMessage(operation), 100);
        });
    }
    
    function handleIncomingMessage(data) {
        if (!data.type) return;
        
        switch(data.type) {
            case 'user_role':
                handleUserRoleMessage(data);
                break;
            case 'current_state':
                handleCurrentStateMessage(data);
                break;
            case 'shape_change':
                if (!state.isLeader) updateShapeSelection(data.shape);
                break;
            case 'breath_toggle':
                if (!state.isLeader) handleBreathToggle(data.isActive);
                break;
            case 'exercise_start':
                if (!state.isLeader) handleExerciseStart();
                break;
            case 'voice_toggle':
                if (!state.isLeader) handleVoiceToggle(data.isActive);
                break;
            case 'vibration_toggle':
                if (!state.isLeader) handleVibrationToggle(data.isActive);
                break;
            case 'save_exercise':
                if (!state.isLeader) handleSaveExercise();
                break;
            case 'show_guide':
                if (!state.isLeader) handleShowGuide();
                break;
            case 'breathing_timing_change':
                if (!state.isLeader) handleBreathingTimingChange(data);
                break;
            case 'close_component':
                if (!state.isLeader) handleCloseComponent(data.componentId);
                break;
            case 'reload_all':
                handleReloadAll(data);
                break;
            case 'heartbeat':
                // Heartbeat received, connection is alive
                break;
            default:
                log(`Unknown message type: ${data.type}`, 'warning');
        }
    }
    
    function handleUserRoleMessage(data) {
        const wasLeader = state.isLeader;
        state.isLeader = data.is_leader;
        state.isReady = true;
        state.connectionStatus = 'ready';
        
        log(`User role: ${state.isLeader ? 'Leader' : 'Follower'}`);
        
        if (wasLeader !== state.isLeader) {
            updateUIForRole();
            setupEventListeners();
        }
        
        showConnectionStatus(
            state.isLeader ? '👑 You are the leader' : '👥 Following leader',
            'success'
        );
    }
    
    function handleCurrentStateMessage(data) {
        log('Received current state from server');
        
        if (!state.isLeader && data.currentState) {
            // Apply current state to follower
            const { shape, timings, activeStates } = data.currentState;
            
            if (shape) updateShapeSelection(shape);
            if (timings) handleBreathingTimingChange(timings);
            if (activeStates) {
                // Apply any active states
                Object.keys(activeStates).forEach(key => {
                    if (activeStates[key]) {
                        switch(key) {
                            case 'breathing':
                                handleBreathToggle(true);
                                break;
                            case 'voice':
                                handleVoiceToggle(true);
                                break;
                            case 'vibration':
                                handleVibrationToggle(true);
                                break;
                        }
                    }
                });
            }
        }
    }
    
    // UI Management
    function updateUIForRole() {
        // Remove existing indicators
        const existingIndicator = document.querySelector('.follower-indicator, .leader-indicator');
        if (existingIndicator) existingIndicator.remove();
        
        const controls = elements['controls-row'];
        if (controls) {
            const indicator = document.createElement('div');
            indicator.className = state.isLeader ? 'leader-indicator' : 'follower-indicator';
            indicator.style.cssText = `
                position: absolute;
                top: -30px;
                left: 50%;
                transform: translateX(-50%);
                background: ${state.isLeader ? 'rgba(76, 175, 80, 0.9)' : 'rgba(33, 150, 243, 0.9)'};
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: bold;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                z-index: 1000;
            `;
            indicator.textContent = state.isLeader ? '👑 Leader Mode' : '👥 Following Leader';
            
            controls.style.position = 'relative';
            controls.appendChild(indicator);
        }
        
        // Disable/enable controls for followers
        if (!state.isLeader) {
            const controlElements = [
                'shapeSelect', 'breathtoggleBtn', 'startButton', 'voice-start',
                'vibration-button-set', 'save-exercise-button-id', 'guide-button-id',
                'inhaleTime', 'holdInTime', 'exhaleTime', 'holdOutTime'
            ];
            
            controlElements.forEach(id => {
                const element = elements[id];
                if (element) {
                    element.style.pointerEvents = 'none';
                    element.style.opacity = '0.7';
                    if (element.tagName === 'SELECT' || element.tagName === 'INPUT') {
                        element.disabled = true;
                    }
                }
            });
        }
    }
    
    // Event listener management
    function setupEventListeners() {
        if (!state.isLeader) return;
        
        log('Setting up leader event listeners');
        
        // Remove existing listeners to prevent duplicates
        removeEventListeners();
        
        // Shape selection
        if (elements.shapeSelect) {
            elements.shapeSelect.addEventListener('change', handleShapeChange);
        }
        
        // Control buttons
        const buttonHandlers = {
            'breathtoggleBtn': () => sendMessage({ type: 'breath_toggle', isActive: true }),
            'startButton': () => sendMessage({ type: 'exercise_start' }),
            'voice-start': (e) => sendMessage({ type: 'voice_toggle', isActive: !e.target.classList.contains('voice-off') }),
            'vibration-button-set': () => sendMessage({ type: 'vibration_toggle', isActive: true }),
            'save-exercise-button-id': () => sendMessage({ type: 'save_exercise' }),
            'guide-button-id': () => sendMessage({ type: 'show_guide' }),
            'reload-all': handleReloadAllClick
        };
        
        Object.keys(buttonHandlers).forEach(id => {
            if (elements[id]) {
                elements[id].addEventListener('click', buttonHandlers[id]);
            }
        });
        
        // Timing controls
        const timingIds = ['inhaleTime', 'holdInTime', 'exhaleTime', 'holdOutTime'];
        timingIds.forEach(id => {
            if (elements[id]) {
                elements[id].addEventListener('change', handleTimingChange);
            }
        });
        
        // Close button monitoring
        setupCloseButtonMonitoring();
        
        log('Leader event listeners set up successfully');
    }
    
    function removeEventListeners() {
        // This would require keeping track of listeners, for now we'll rely on the fact
        // that we're only adding listeners once per role change
    }
    
    function handleShapeChange(e) {
        sendMessage({
            type: 'shape_change',
            shape: e.target.value
        });
    }
    
    function handleTimingChange() {
        const timings = {
            inhaleTime: elements.inhaleTime?.value,
            holdInTime: elements.holdInTime?.value,
            exhaleTime: elements.exhaleTime?.value,
            holdOutTime: elements.holdOutTime?.value
        };
        
        log('Sending timing change:', timings);
        sendMessage({
            type: 'breathing_timing_change',
            ...timings
        });
    }
    
    function handleReloadAllClick() {
        const message = 'This will reconnect all users but the current exercise will be stopped. Continue?';
        if (confirm(message)) {
            log('Leader initiated reload all');
            
            sendMessage({
                type: 'reload_all',
                leader: userName
            });
            
            setTimeout(() => window.location.reload(), 500);
        }
    }
    
    function setupCloseButtonMonitoring() {
        const closeSelectors = [
            '#breath-close', '#close-button', '#modal-close', '#popup-close',
            '.close-btn', '.modal-close', '[data-dismiss]', '[data-close]'
        ];
        
        // Use single delegated listener
        document.addEventListener('click', function(e) {
            if (!state.isLeader) return;
            
            const target = e.target;
            const matchedSelector = closeSelectors.find(selector => target.matches?.(selector));
            
            if (matchedSelector) {
                const componentId = target.id || target.getAttribute('data-close') || 'modal';
                log(`Leader closed component: ${componentId}`);
                
                sendMessage({
                    type: 'close_component',
                    componentId: componentId
                });
            }
        });
        
        // ESC key monitoring
        document.addEventListener('keydown', function(e) {
            if (!state.isLeader || e.key !== 'Escape') return;
            
            const openModals = document.querySelectorAll('.modal.show, .popup.open, [style*="display: block"]');
            openModals.forEach(modal => {
                if (modal.id) {
                    sendMessage({
                        type: 'close_component',
                        componentId: modal.id
                    });
                }
            });
        });
    }
    
    // Follower action handlers
    function updateShapeSelection(shape) {
        if (elements.shapeSelect && elements.shapeSelect.value !== shape) {
            elements.shapeSelect.value = shape;
            elements.shapeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            log(`Updated shape to: ${shape}`);
        }
    }
    
    function handleBreathToggle(isActive) {
        const btn = elements.breathtoggleBtn;
        if (btn) {
            btn.click();
            log('Triggered breath toggle');
        }
    }
    
    function handleExerciseStart() {
        const btn = elements.startButton;
        if (btn) {
            btn.click();
            log('Triggered exercise start');
        }
    }
    
    function handleVoiceToggle(isActive) {
        const btn = elements['voice-start'];
        if (btn) {
            btn.click();
            log('Triggered voice toggle');
        }
    }
    
    function handleVibrationToggle(isActive) {
        const btn = elements['vibration-button-set'];
        if (btn) {
            btn.click();
            log('Triggered vibration toggle');
        }
    }
    
    function handleSaveExercise() {
        const btn = elements['save-exercise-button-id'];
        if (btn) {
            btn.click();
            log('Triggered save exercise');
        }
    }
    
    function handleShowGuide() {
        const btn = elements['guide-button-id'];
        if (btn) {
            btn.click();
            log('Triggered show guide');
        }
    }
    
    function handleBreathingTimingChange(data) {
        const { inhaleTime, holdInTime, exhaleTime, holdOutTime } = data;
        log('Applying timing changes:', data);
        
        // Update timing controls
        const timingMap = {
            inhaleTime: 'inhaleTime',
            holdInTime: 'holdInTime',
            exhaleTime: 'exhaleTime',
            holdOutTime: 'holdOutTime'
        };
        
        // Temporarily enable controls for followers
        Object.keys(timingMap).forEach(key => {
            const element = elements[timingMap[key]];
            if (element && data[key] !== undefined) {
                const wasDisabled = element.disabled;
                element.disabled = false;
                element.value = data[key];
                element.disabled = wasDisabled;
                
                // Trigger change events
                element.dispatchEvent(new Event('change', { bubbles: true }));
                element.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });
        
        // Try to trigger global update functions
        setTimeout(() => {
            const updateFunctions = [
                'updateBreathingTiming', 'updateTiming', 'setBreathingTiming',
                'changeBreathingTiming', 'applyBreathingTiming'
            ];
            
            const timingValues = {
                inhale: parseInt(inhaleTime) || 4,
                holdIn: parseInt(holdInTime) || 4,
                exhale: parseInt(exhaleTime) || 4,
                holdOut: parseInt(holdOutTime) || 4
            };
            
            updateFunctions.forEach(funcName => {
                if (window[funcName] && typeof window[funcName] === 'function') {
                    try {
                        window[funcName](timingValues);
                        log(`Called ${funcName} successfully`);
                    } catch (e) {
                        log(`Error calling ${funcName}: ${e.message}`, 'warning');
                    }
                }
            });
            
            // Try jQuery trigger if available
            if (window.jQuery) {
                window.jQuery('#inhaleTime, #holdInTime, #exhaleTime, #holdOutTime').trigger('change');
            }
        }, 100);
    }
    
    function handleCloseComponent(componentId) {
        log(`Closing component: ${componentId}`);
        
        const component = document.getElementById(componentId);
        if (!component) return;
        
        // Try multiple close methods
        const closeMethods = [
            () => component.click(), // If it's a close button
            () => { component.style.display = 'none'; },
            () => {
                // Hide parent modal/popup
                let parent = component.parentElement;
                while (parent && parent !== document.body) {
                    if (parent.classList.contains('modal') || 
                        parent.classList.contains('popup') || 
                        parent.classList.contains('overlay')) {
                        parent.style.display = 'none';
                        break;
                    }
                    parent = parent.parentElement;
                }
            },
            () => {
                // Remove active classes
                const activeClasses = ['active', 'open', 'show', 'visible'];
                activeClasses.forEach(className => {
                    component.classList.remove(className);
                    if (component.parentElement) {
                        component.parentElement.classList.remove(className);
                    }
                });
            }
        ];
        
        closeMethods.forEach((method, index) => {
            try {
                method();
            } catch (e) {
                log(`Close method ${index} failed: ${e.message}`, 'warning');
            }
        });
        
        // Dispatch close events
        component.dispatchEvent(new Event('close', { bubbles: true }));
        component.dispatchEvent(new CustomEvent('component-close', { 
            bubbles: true, 
            detail: { componentId } 
        }));
    }
    
    function handleReloadAll(data) {
        log(`Received reload command from leader: ${data.leader}`);
        
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 20000;
            font-size: 18px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        `;
        notification.innerHTML = `
            <div style="margin-bottom: 15px; font-size: 24px;">🔄</div>
            <div>Leader <strong>${data.leader}</strong> is reconnecting...</div>
            <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">Please wait...</div>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => window.location.reload(), 2000);
    }
    
    // Page lifecycle management
    function handleVisibilityChange() {
        if (document.hidden) {
            log('Page hidden, maintaining connection');
        } else {
            log('Page visible, checking connection');
            if (!state.isConnected) {
                initializeWebSocket();
            }
        }
    }
    
    function handleBeforeUnload() {
        log('Page unloading, cleaning up');
        if (state.socket) {
            state.socket.close(1000, 'Page unload');
        }
        stopHeartbeat();
    }
    
    // Initialization
    function waitForDOMReady() {
        return new Promise((resolve) => {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resolve);
            } else {
                resolve();
            }
        });
    }
    
    function checkReadiness() {
        return new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = CONFIG.READY_CHECK_TIMEOUT / CONFIG.READY_CHECK_INTERVAL;
            
            const checkInterval = setInterval(() => {
                attempts++;
                
                // Check if essential elements are available
                const essentialElements = ['controls-row'];
                const elementsReady = essentialElements.every(id => document.getElementById(id));
                
                if (elementsReady || attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                    if (elementsReady) {
                        resolve();
                    } else {
                        reject(new Error('Timeout waiting for DOM elements'));
                    }
                }
            }, CONFIG.READY_CHECK_INTERVAL);
        });
    }
    
    async function initialize() {
        try {
            log('Starting initialization...');
            
            // Wait for DOM
            await waitForDOMReady();
            log('DOM ready');
            
            // Wait for essential elements
            await checkReadiness();
            log('Essential elements ready');
            
            // Cache DOM elements
            cacheElements();
            
            // Set up page lifecycle handlers
            document.addEventListener('visibilitychange', handleVisibilityChange);
            window.addEventListener('beforeunload', handleBeforeUnload);
            
            // Initialize WebSocket connection
            initializeWebSocket();
            
            log('Initialization complete');
            
        } catch (error) {
            log(`Initialization failed: ${error.message}`, 'error');
            showConnectionStatus('Initialization failed. Please refresh the page.', 'error');
        }
    }
    
    // Start the application
    initialize();
    
})();
</script> -->
<style>
    @media (max-width: 800px) {
  .action-buttons {
    padding: 10px;
    padding-top: 20px;
  }
}
</style>
{% endblock content %}
