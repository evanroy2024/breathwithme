<!-- templates/exercises/exercise_play.html -->
<!DOCTYPE html>
{% load static %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ exercise.name }} - Breathing Exercise</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .header {
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .back-btn {
            background-color: transparent;
            color: #e0e0e0;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: #e0e0e0;
            text-align: center;
            margin-bottom: 20px;
        }
        .exercise-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }
        .shape-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .phase-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            color: #e0e0e0;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        /* Shape styles */
        .circle {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 4px solid #4dabf7;
            position: relative;
        }
        .square {
            width: 300px;
            height: 300px;
            border: 4px solid #be4bdb;
            position: relative;
        }
        .rectangle {
            width: 350px;
            height: 175px;
            border: 4px solid #ff6b6b;
            position: relative;
        }
        .oval {
            width: 300px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid #fcc419;
            position: relative;
        }
        .triangle {
    position: relative;
    width: 300px;
    height: 260px; /* Height for equilateral triangle (adjusted proportionally) */
}

/* Outer green triangle */
.triangle:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 0;
    height: 0;
    border-left: 150px solid transparent;
    border-right: 150px solid transparent;
    border-bottom: 260px solid #51cf66;
    z-index: 1;
}

/* Inner black triangle (creating outline effect) */
.triangle:after {
    content: '';
    position: absolute;
    top: 4px; /* Controls border thickness */
    left: 4px;
    width: 0;
    height: 0;
    border-left: 146px solid transparent;
    border-right: 146px solid transparent;
    border-bottom: 253px solid #121212; /* Should match background color */
    z-index: 2;
}

.reversedtriangle {
    position: relative;
    width: 300px;
    height: 260px; /* Height for equilateral triangle (adjusted proportionally) */
}

/* Outer green reversed triangle */
.reversedtriangle:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 0;
    height: 0;
    border-left: 150px solid transparent;
    border-right: 150px solid transparent;
    border-top: 255px solid #20c997;
    z-index: 1;
}

/* Inner black reversed triangle (creating outline effect) */
.reversedtriangle:after {
    content: '';
    position: absolute;
    top: 4px; /* Creates space for the top edge */
    left: 4px;
    width: 0;
    height: 0;
    border-left: 146px solid transparent;
    border-right: 146px solid transparent;
    border-top: 246px solid #121212; /* Should match background color */
    z-index: 2;
}
        .quadrilateral {
            width: 300px;
            height: 300px;
            transform: rotate(45deg);
            border: 4px solid #40c057;
            position: relative;
        }
        
        /* Ball styles */
        .ball {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #ffffff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }
        
        .controls {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .start-btn {
            background-color: #40c057;
            color: #121212;
        }
        .pause-btn {
            background-color: #fcc419;
            color: #121212;
        }
        .reset-btn {
            background-color: #ff6b6b;
            color: #121212;
        }
        .progress-info {
            margin-top: 20px;
            text-align: center;
            font-size: 1.2rem;
            color: #e0e0e0;
        }
        
        /* Path for debugging - can be removed in production */
        .debug-path {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
        }


.main-heading {
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
}

.header-container {
  display: flex;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
}

.back-button {
  background: transparent;
  border: none;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  margin-right: 15px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.title {
  color: white;
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
  letter-spacing: 0.5px;
}
    </style>
</head>
<body>
    <div class="container">
        
        <div class="main-heading">
            <div class="header-container">
              <button class="back-button" onclick="window.location.href='{% url 'breathxapp:exercise_list' %}'">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
              </button>
              <h1 class="title">BreathFree-Meditation</h1>
            </div>
          </div>
          <hr style="width: 400px; height: 5px;  background: linear-gradient(to right, #6e8efb, #a777e3); border-radius: 10px;">
        

        <div class="exercise-display">
            <div class="shape-container">
                <div class="phase-info"></div>
                <div id="shape-element" class=""></div>
                <div id="ball" class="ball" style="display: none;"></div>
                <svg id="debug-path" class="debug-path" width="300" height="300" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
            <div class="controls-container">
                <div class="buttons-row">
                    <button class="control-btn start-btn" id="start-btn" aria-label="Start">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="control-btn pause-btn" id="pause-btn" disabled aria-label="Pause">
                        <i class="fas fa-pause"></i>
                    </button>
                    <button class="control-btn reset-btn" id="reset-btn" disabled aria-label="Reset">
                        <i class="fas fa-redo"></i>
                    </button>
                  
                    <!-- Add this button where your other controls are -->
                    <button id="voice-toggle-btn" class="control-btn">
                        <i class="fas fa-volume-mute"></i>
                    </button>
                    <button class="control-btn"  aria-label="Enable Vibration">
                        <i class="fas fa-bell-slash"></i>
                    </button>
                    
                </div>
                
                <div class="progress-row">
                    <div id="phase-progress">Ready to start</div>
                    <div id="cycle-progress"></div>
                </div>
            </div>
            
            <style>
                .controls-container {
                    background: rgba(18, 18, 20, 0.7);
                    backdrop-filter: blur(10px);
                    border-radius: 16px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    margin: 0 auto;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                }
                
                .buttons-row {
                    display: flex;
                    justify-content: center;
                    gap: 16px;
                }
                
                .control-btn {
                    width: 56px;
                    height: 56px;
                    border: none;
                    border-radius: 50%;
                    font-size: 18px;
                    transition: all 0.3s ease;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: rgba(30, 30, 35, 0.9);
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                    position: relative;
                }
                
                .control-btn::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    border-radius: 50%;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-sizing: border-box;
                }
                
                .control-btn:hover {
                    transform: translateY(-3px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
                }
                
                .control-btn:active {
                    transform: translateY(1px);
                }
                
                .start-btn {
                    color: #4ade80;
                }
                
                .start-btn:hover {
                    background: rgba(40, 45, 40, 0.9);
                }
                
                .pause-btn {
                    color: #fcd34d;
                }
                
                .pause-btn:hover {
                    background: rgba(45, 42, 35, 0.9);
                }
                
                .reset-btn {
                    color: #f87171;
                }
                
                .reset-btn:hover {
                    background: rgba(45, 35, 35, 0.9);
                }
                
                .voice-btn {
                    color: #60a5fa;
                }
                
                .voice-btn:hover {
                    background: rgba(35, 40, 45, 0.9);
                }
                
                .control-btn:disabled {
                    opacity: 0.4;
                    cursor: not-allowed;
                    transform: none;
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
                }
                
                .progress-row {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    color: rgba(255, 255, 255, 0.9);
                    font-family: 'Inter', sans-serif;
                    text-align: center;
                }
                
                #phase-progress {
                    font-size: 18px;
                    font-weight: 500;
                    letter-spacing: 0.3px;
                    color: #e4e4e7;
                }
                
                #cycle-progress {
                    font-size: 16px;
                    color: #a1a1aa;
                    letter-spacing: 0.2px;
                }
                
                /* Responsive adjustments */
                @media (max-width: 480px) {
                    .controls-container {
                        padding: 16px;
                        gap: 16px;
                    }
                    
                    .buttons-row {
                        gap: 12px;
                    }
                    
                    .control-btn {
                        width: 48px;
                        height: 48px;
                        font-size: 16px;
                    }
                    
                    #phase-progress {
                        font-size: 16px;
                    }
                    
                    #cycle-progress {
                        font-size: 14px;
                    }
                }
            </style>
            
            <!-- Add this line in the head section of your HTML document -->
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        </div>
    </div>
  
<script>
// Get exercise phases data from Django
const phasesData = {{ phases_data|safe }};

// DOM elements
const shapeElement = document.getElementById('shape-element');
const ball = document.getElementById('ball');
const debugPath = document.getElementById('debug-path');
const phaseInfo = document.querySelector('.phase-info');
const phaseProgress = document.getElementById('phase-progress');
const cycleProgress = document.getElementById('cycle-progress');
const startBtn = document.getElementById('start-btn');
const pauseBtn = document.getElementById('pause-btn');
const resetBtn = document.getElementById('reset-btn');

// JavaScript to add to your script
// Add this to the Event listeners section
voiceToggleBtn = document.getElementById('voice-toggle-btn');
voiceToggleBtn.addEventListener('click', toggleVoice);

// Current state
let currentPhaseIndex = 0;
let currentBreathingPhaseIndex = 0;
let currentEdgeIndex = 0;
let currentCycle = 1;
let isRunning = false;
let timer = null;
let animationId = null;
let lastSpokenPhase = ''; // Track last spoken phrase to avoid repetition

// Ball animation parameters
let ballPosition = 0;
let animationStartTime = null;
let animationDuration = 5000; // Default duration (ms)

// Speech synthesis
const synth = window.speechSynthesis;

// Path coordinates for each shape
const shapePaths = {};

// Edge segments for multi-edge shapes
const shapeEdges = {};

// Shape color mappings for glowing effect
const shapeColors = {
    'circle': '#3498db', // Blue
    'square': '#2ecc71', // Green
    'rectangle': '#e74c3c', // Red
    'triangle': '#f39c12', // Orange
    'reversedtriangle': '#9b59b6', // Purple
    'quadrilateral': '#1abc9c', // Turquoise
    'oval': '#d35400', // Dark Orange
    'default': '#3498db' // Default blue
};


// Voice -------------------------------------------------------------------
const audioFiles = {
    'Inhale': new Audio("{% static 'voices/inhale.mp3' %}"),
    'Hold': new Audio("{% static 'voices/hold.mp3' %}"),
    'Exhale': new Audio("{% static 'voices/exhale.mp3' %}")
};
let voiceEnabled = false; // Voice starts off by default


// Initialize
updateShapeDisplay();
applyGlowEffect();

// Event listeners
startBtn.addEventListener('click', startExercise);
pauseBtn.addEventListener('click', pauseExercise);
resetBtn.addEventListener('click', resetExercise);

// 3. Make sure startExercise explicitly applies the glow
function startExercise() {
    if (!isRunning) {
        isRunning = true;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        resetBtn.disabled = false;
        
        // Explicitly apply glow effect when starting
        applyGlowEffect();
        
        runCurrentEdge();
    }
}
// Make sure to update these functions to stop audio playback
function pauseExercise() {
    if (isRunning) {
        isRunning = false;
        clearTimeout(timer);
        cancelAnimationFrame(animationId);
        startBtn.disabled = false;
        startBtn.innerHTML = '<i class="fas fa-play"></i>';
        
        // Stop any ongoing audio playback
        Object.values(audioFiles).forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
    }
}


function resetExercise() {
    isRunning = false;
    clearTimeout(timer);
    cancelAnimationFrame(animationId);
    currentPhaseIndex = 0;
    currentBreathingPhaseIndex = 0;
    currentEdgeIndex = 0;
    currentCycle = 1;
    startBtn.disabled = false;
    startBtn.textContent = 'Start';
    pauseBtn.disabled = true;
    resetBtn.disabled = true;
    ball.style.display = 'none';
    
    // Stop any ongoing audio playback
    Object.values(audioFiles).forEach(audio => {
        audio.pause();
        audio.currentTime = 0;
    });
    
    lastSpokenPhase = '';
    
    // Get the current shape before updating display
    const shape = phasesData[currentPhaseIndex].shape.toLowerCase();
    
    updateShapeDisplay();
    
    // Apply appropriate resetting based on shape type
    if (shape === 'triangle') {
        shapeElement.style.filter = "none";
        shapeElement.style.boxShadow = "none";
        shapeElement.style.border = "none";
        updateTriangleGlowColor('transparent');
    } else if (shape === 'reversedtriangle') {
        shapeElement.style.filter = "none";
        shapeElement.style.boxShadow = "none";
        shapeElement.style.border = "none";
        updateReversedTriangleGlowColor('transparent');
    } else {
        shapeElement.style.boxShadow = "none";
        shapeElement.style.filter = "none";
        shapeElement.style.border = "1px solid rgba(200, 200, 200, 0.3)"; // Very subtle neutral border
    }
    
    // Also remove ball glow
    if (ball) {
        ball.style.boxShadow = "none";
    }
}
function runCurrentEdge() {
    if (!isRunning) return;
    
    const phase = phasesData[currentPhaseIndex];
    if (!phase) {
        // Exercise completed
        resetExercise();
        phaseProgress.textContent = 'Exercise completed!';
        return;
    }
    
    // Update shape display for current phase
    updateShapeDisplay();
    applyGlowEffect();
    
    // Create path for the current shape if it doesn't exist
    createShapePath(phase.shape);
    
    // Get total number of edges for this shape
    const totalEdges = getEdgeCount(phase.shape);
    
    // Get current breathing phase
    const breathingPhases = phase.breathing_phases;
    const currentBreathingPhase = breathingPhases[currentBreathingPhaseIndex];
    
    // Determine if this is a circular shape
    const isCircularShape = ['circle', 'oval'].includes(phase.shape.toLowerCase());
    
    // Get duration for current edge/phase
    let duration;
    if (isCircularShape) {
        // For circle/oval, use the specified duration for each full circle
        duration = phase.inputs[currentBreathingPhaseIndex] || 0;
    } else {
        // For other shapes, use the specified duration for each edge
        duration = phase.inputs[0] || 0;
    }
    
    // Update display
    updateBreathingPhaseDisplay(phase.shape, currentBreathingPhase, duration);
    
    // For multi-edge shapes, we need to determine which edge to animate
    let edgePoints;
    
    if (isCircularShape) {
        // For circular shapes, use the full path for animation
        edgePoints = shapePaths[phase.shape];
    } else {
        // For shapes with distinct edges, use the appropriate edge
        edgePoints = shapeEdges[phase.shape][currentEdgeIndex];
    }
    
    // Start ball animation for this edge
    if (isCircularShape) {
        // For circular shapes, use full circle animation
        startCircularAnimation(phase, edgePoints, duration);
    } else {
        // For other shapes, we animate along the edge
        startEdgeAnimation(phase, edgePoints, duration);
    }
    
    // Schedule next edge
    timer = setTimeout(() => {
        goToNextEdge(phase);
    }, duration * 1000);
}

function getEdgeCount(shape) {
    switch(shape.toLowerCase()) {
        case 'circle':
        case 'oval':
            return 1; // Circular shapes are treated specially
        case 'triangle':
        case 'reversedtriangle':
            return 3;
        case 'square':
        case 'rectangle':
        case 'quadrilateral':
            return 4;
        default:
            return 1;
    }
}

function goToNextEdge(phase) {
    const isCircularShape = ['circle', 'oval'].includes(phase.shape.toLowerCase());
    const totalEdges = getEdgeCount(phase.shape);
    
    // Update breathing phase index
    currentBreathingPhaseIndex = (currentBreathingPhaseIndex + 1) % phase.breathing_phases.length;
    
    // For non-circular shapes, update edge index
    if (!isCircularShape) {
        currentEdgeIndex = (currentEdgeIndex + 1) % totalEdges;
        
        // If we've completed all edges, increment cycle
        if (currentEdgeIndex === 0) {
            currentCycle++;
        }
    } else {
        // For circular shapes, if we've completed all breathing phases, increment cycle
        if (currentBreathingPhaseIndex === 0) {
            currentCycle++;
        }
    }
    
    // Check if we completed all cycles for this shape
    if (currentCycle > phase.cycles) {
        currentCycle = 1;
        currentEdgeIndex = 0;
        currentBreathingPhaseIndex = 0;
        currentPhaseIndex++;
        
        // Force shape update for the next phase
        updateShapeDisplay();
        applyGlowEffect();
    }
    
    runCurrentEdge();
}


function toggleVoice() {
    voiceEnabled = !voiceEnabled;
    
    // Update button icon
    if (voiceEnabled) {
        voiceToggleBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        voiceToggleBtn.title = 'Disable voice guidance';
    } else {
        voiceToggleBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
        voiceToggleBtn.title = 'Enable voice guidance';
    }
}

// Update the speakBreathingPhase function to only play audio when voice is enabled
function speakBreathingPhase(text) {
    if (!voiceEnabled) return; // Skip audio if voice is disabled
    
    // Extract just the breathing instruction (inhale, exhale, hold)
    let speechText = text.toLowerCase();
    
    // Check for each breathing instruction
    if (speechText.includes('inhale') || speechText.includes('breathe in')) {
        // Stop any currently playing audio
        Object.values(audioFiles).forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
        
        // Play the inhale audio immediately
        audioFiles['Inhale'].play();
        lastSpokenPhase = 'inhale';
    } 
    else if (speechText.includes('hold') || speechText.includes('retain')) {
        // Stop any currently playing audio
        Object.values(audioFiles).forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
        
        // Play the hold audio immediately
        audioFiles['Hold'].play();
        lastSpokenPhase = 'hold';
    } 
    else if (speechText.includes('exhale') || speechText.includes('breathe out')) {
        // Stop any currently playing audio
        Object.values(audioFiles).forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
        
        // Play the exhale audio immediately
        audioFiles['Exhale'].play();
        lastSpokenPhase = 'exhale';
    }
}


function updateBreathingPhaseDisplay(shape, breathingPhase, duration) {
    // Clear previous classes
    shapeElement.className = '';
    
    // Set shape class
    shapeElement.classList.add(shape.toLowerCase());
    
    // Update text displays
    phaseInfo.textContent = breathingPhase;
    phaseProgress.textContent = `Phase: ${currentPhaseIndex + 1}/${phasesData.length} - ${breathingPhase} (${duration}s)`;
    cycleProgress.textContent = `Cycle: ${currentCycle}/${phasesData[currentPhaseIndex].cycles}`;
    
    // Update glow effect based on breathing phase
    updateGlowIntensity(breathingPhase);
    
    // Speak the breathing phase instruction
    speakBreathingPhase(breathingPhase);
}

function updateShapeDisplay() {
    const phase = phasesData[currentPhaseIndex];
    if (!phase) return;
    
    // Clear previous classes
    shapeElement.className = '';
    
    // Set shape class
    shapeElement.classList.add(phase.shape.toLowerCase());
    
    // Reset text displays
    if (!isRunning) {
        phaseInfo.textContent = 'Ready';
        phaseProgress.textContent = 'Ready to start';
        cycleProgress.textContent = `Phase: ${currentPhaseIndex + 1}/${phasesData.length}`;
    }
    
    // Important: Clear previous paths for this shape to force recalculation
    delete shapePaths[phase.shape];
    delete shapeEdges[phase.shape];
    
    // Create path for the shape
    createShapePath(phase.shape);
}


// Function to update glow intensity based on breathing phase
function updateGlowIntensity(breathingPhase) {
    const phase = phasesData[currentPhaseIndex];
    if (!phase) return;
    
    const shape = phase.shape.toLowerCase();
    const color = shapeColors[shape] || shapeColors['default'];
    
    // Adjust glow intensity based on breathing phase
    if (breathingPhase.toLowerCase().includes('inhale')) {
        // Stronger glow for inhale
        shapeElement.style.boxShadow = `0 0 25px ${color}, 0 0 40px ${color}`;
        ball.style.boxShadow = `0 0 15px ${color}, 0 0 30px ${color}`;
    } else {
        // Softer glow for exhale
        shapeElement.style.boxShadow = `0 0 10px ${color}, 0 0 20px ${color}`;
        ball.style.boxShadow = `0 0 8px ${color}, 0 0 15px ${color}`;
    }
}

function createShapePath(shape) {
    // Don't recreate if already exists
    if (shapePaths[shape]) return;
    
    // Get shape element dimensions
    const shapeRect = shapeElement.getBoundingClientRect();
    const containerRect = document.querySelector('.shape-container').getBoundingClientRect();
    
    // Adjust coordinates to be relative to container
    const offsetX = shapeRect.left - containerRect.left;
    const offsetY = shapeRect.top - containerRect.top;
    
    // Path points array
    let points = [];
    let edges = [];
    
    switch(shape.toLowerCase()) {
        case 'circle':
            // Create points around a circle
            const circleRadius = shapeRect.width / 2;
            const centerX = offsetX + circleRadius;
            const centerY = offsetY + circleRadius;
            
            // Create more points for smoother animation (360 points for a circle - one per degree)
            // Start from the top (12 o'clock) position: -90 degrees in radians is -Math.PI/2
            for (let i = 0; i <= 360; i++) {
                const angle = ((i / 360) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = centerX + Math.cos(angle) * circleRadius;
                const y = centerY + Math.sin(angle) * circleRadius;
                points.push({ x, y });
            }
            break;
            
        case 'square':
            // Create points around a square
            const squareLeft = offsetX;
            const squareTop = offsetY;
            const squareRight = offsetX + shapeRect.width;
            const squareBottom = offsetY + shapeRect.height;
            
            // Top edge (left to right)
            const topEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = squareLeft + (squareRight - squareLeft) * (i / 100);
                topEdge.push({ x, y: squareTop });
            }
            
            // Right edge (top to bottom)
            const rightEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = squareTop + (squareBottom - squareTop) * (i / 100);
                rightEdge.push({ x: squareRight, y });
            }
            
            // Bottom edge (right to left)
            const bottomEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = squareRight - (squareRight - squareLeft) * (i / 100);
                bottomEdge.push({ x, y: squareBottom });
            }
            
            // Left edge (bottom to top)
            const leftEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = squareBottom - (squareBottom - squareTop) * (i / 100);
                leftEdge.push({ x: squareLeft, y });
            }
            
            // Store edges separately for phase tracking
            edges = [topEdge, rightEdge, bottomEdge, leftEdge];
            points = [...topEdge, ...rightEdge, ...bottomEdge, ...leftEdge];
            break;
            
        case 'rectangle':
            // Create points around a rectangle
            const rectLeft = offsetX;
            const rectTop = offsetY;
            const rectRight = offsetX + shapeRect.width;
            const rectBottom = offsetY + shapeRect.height;
            
            // Top edge (left to right)
            const rectTopEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = rectLeft + (rectRight - rectLeft) * (i / 100);
                rectTopEdge.push({ x, y: rectTop });
            }
            
            // Right edge (top to bottom)
            const rectRightEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = rectTop + (rectBottom - rectTop) * (i / 100);
                rectRightEdge.push({ x: rectRight, y });
            }
            
            // Bottom edge (right to left)
            const rectBottomEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = rectRight - (rectRight - rectLeft) * (i / 100);
                rectBottomEdge.push({ x, y: rectBottom });
            }
            
            // Left edge (bottom to top)
            const rectLeftEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = rectBottom - (rectBottom - rectTop) * (i / 100);
                rectLeftEdge.push({ x: rectLeft, y });
            }
            
            // Store edges separately for phase tracking
            edges = [rectTopEdge, rectRightEdge, rectBottomEdge, rectLeftEdge];
            points = [...rectTopEdge, ...rectRightEdge, ...rectBottomEdge, ...rectLeftEdge];
            break;
            
        case 'oval':
            // Create points around an oval
            const ovalRadiusX = shapeRect.width / 2;
            const ovalRadiusY = shapeRect.height / 2;
            const ovalCenterX = offsetX + ovalRadiusX;
            const ovalCenterY = offsetY + ovalRadiusY;
            
            // Create more points for smoother animation (360 points for an oval - one per degree)
            // Start from the top (12 o'clock) position: -90 degrees in radians is -Math.PI/2
            for (let i = 0; i <= 360; i++) {
                const angle = ((i / 360) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = ovalCenterX + Math.cos(angle) * ovalRadiusX;
                const y = ovalCenterY + Math.sin(angle) * ovalRadiusY;
                points.push({ x, y });
            }
            break;
            
            case 'triangle':
            document.querySelectorAll('.phase-info').forEach(el => {
            el.style.top = '55%';  // Set top to 60% for triangle
        });
    // Create points for an equilateral triangle
    const triWidth = shapeRect.width;
    const triHeight = shapeRect.height;
    
    // Calculate the three points of the triangle
    const triLeft = offsetX;
    const triTop = offsetY;
    
    // Define the three vertices precisely
    const point1 = { x: triLeft + triWidth/2, y: triTop }; // Top
    const point2 = { x: triLeft, y: triTop + triHeight }; // Bottom-left
    const point3 = { x: triLeft + triWidth, y: triTop + triHeight }; // Bottom-right
    
    // RIGHT edge (top to bottom-right) - CLOCKWISE DIRECTION
    const triRightEdge = createLinePoints(point1, point3, 100);
    
    // Bottom edge (bottom-right to bottom-left) - CLOCKWISE DIRECTION
    const triBottomEdge = createLinePoints(point3, point2, 100);
    
    // Left edge (bottom-left to top) - CLOCKWISE DIRECTION
    const triLeftEdge = createLinePoints(point2, point1, 100);
    
    edges = [triRightEdge, triBottomEdge, triLeftEdge];
    points = [...triRightEdge, ...triBottomEdge, ...triLeftEdge];
    break;
    
case 'reversedtriangle':
    document.querySelectorAll('.phase-info').forEach(el => {
            el.style.top = '44%';  // Set top to 60% for triangle
        });
    // Create points for a reversed equilateral triangle
    const revTriWidth = shapeRect.width;
    const revTriHeight = shapeRect.height;
    
    // Calculate the three points of the triangle
    const revTriLeft = offsetX;
    const revTriTop = offsetY;
    
    const revPoint1 = { x: revTriLeft + revTriWidth/2, y: revTriTop + revTriHeight }; // Bottom
    const revPoint2 = { x: revTriLeft, y: revTriTop }; // Top-left
    const revPoint3 = { x: revTriLeft + revTriWidth, y: revTriTop }; // Top-right
    
    // LEFT edge (bottom to top-left) - CLOCKWISE DIRECTION
    const revLeftSegmentPoints = createLinePoints(revPoint1, revPoint2, 100);
    
    // Top edge (top-left to top-right) - CLOCKWISE DIRECTION
    const revTopSegmentPoints = createLinePoints(revPoint2, revPoint3, 100);
    
    // Right edge (top-right to bottom) - CLOCKWISE DIRECTION
    const revRightSegmentPoints = createLinePoints(revPoint3, revPoint1, 100);
    
    edges = [revLeftSegmentPoints, revTopSegmentPoints, revRightSegmentPoints];
    points = [...revLeftSegmentPoints, ...revTopSegmentPoints, ...revRightSegmentPoints];
    break;
        case 'quadrilateral':
            // Create points for a diamond (rotated square)
            const diamondSize = Math.min(shapeRect.width, shapeRect.height);
            const diamondCenterX = offsetX + shapeRect.width / 2;
            const diamondCenterY = offsetY + shapeRect.height / 2;
            
            // Calculate the four points of the rotated square
            const dTop = { x: diamondCenterX, y: diamondCenterY - diamondSize/2 };
            const dRight = { x: diamondCenterX + diamondSize/2, y: diamondCenterY };
            const dBottom = { x: diamondCenterX, y: diamondCenterY + diamondSize/2 };
            const dLeft = { x: diamondCenterX - diamondSize/2, y: diamondCenterY };
            
            // Create path segments with more points for smoother animation
            // Top-right edge
            const topRightPoints = createLinePoints(dTop, dRight, 100);
            // Bottom-right edge
            const bottomRightPoints = createLinePoints(dRight, dBottom, 100);
            // Bottom-left edge
            const bottomLeftPoints = createLinePoints(dBottom, dLeft, 100);
            // Top-left edge
            const topLeftPoints = createLinePoints(dLeft, dTop, 100);
            
            edges = [topRightPoints, bottomRightPoints, bottomLeftPoints, topLeftPoints];
            points = [...topRightPoints, ...bottomRightPoints, ...bottomLeftPoints, ...topLeftPoints];
            break;
            
        default:
            // Default fallback for any unsupported shapes
            const fallbackRadius = Math.min(shapeRect.width, shapeRect.height) / 2;
            const fallbackCenterX = offsetX + shapeRect.width / 2;
            const fallbackCenterY = offsetY + shapeRect.height / 2;
            
            for (let i = 0; i <= 100; i++) {
                const angle = ((i / 100) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = fallbackCenterX + Math.cos(angle) * fallbackRadius;
                const y = fallbackCenterY + Math.sin(angle) * fallbackRadius;
                points.push({ x, y });
            }
    }
    
    // Store the path and edges
    shapePaths[shape] = points;
    shapeEdges[shape] = edges.length > 0 ? edges : [points];
    
    // Debug: Draw path on canvas (uncomment for debugging)
    // drawDebugPath(points);
}

function createLinePoints(start, end, numPoints) {
    const points = [];
    for (let i = 0; i <= numPoints; i++) {
        const ratio = i / numPoints;
        const x = start.x + (end.x - start.x) * ratio;
        const y = start.y + (end.y - start.y) * ratio;
        points.push({ x, y });
    }
    return points;
}

// Debug function to visualize the path
function drawDebugPath(points) {
    // Clear previous path
    while (debugPath.firstChild) {
        debugPath.removeChild(debugPath.firstChild);
    }
    
    if (points.length < 2) return;
    
    // Create a path element
    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    
    // Build path data
    let pathData = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
        pathData += ` L ${points[i].x} ${points[i].y}`;
    }
    pathData += ' Z'; // Close the path
    
    // Set path attributes
    pathElement.setAttribute('d', pathData);
    pathElement.setAttribute('stroke', 'red');
    pathElement.setAttribute('stroke-width', '2');
    pathElement.setAttribute('fill', 'none');
    
    // Add path to SVG
    debugPath.appendChild(pathElement);
    debugPath.style.opacity = '0.5'; // Make visible for debugging
}

// Function for edge animation (non-circular shapes)
function startEdgeAnimation(phase, edgePoints, duration) {
    // Show the ball
    ball.style.display = 'block';
    
    // Convert duration to milliseconds
    animationDuration = duration * 1000;
    animationStartTime = null;
    
    // Start animation loop
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame((timestamp) => animateAlongEdge(timestamp, edgePoints));
}

// Animation loop for non-circular shapes
function animateAlongEdge(timestamp, edgePoints) {
    if (!animationStartTime) animationStartTime = timestamp;
    if (!isRunning) return;
    
    const elapsedTime = timestamp - animationStartTime;
    const progress = Math.min(elapsedTime / animationDuration, 1);
    
    // Calculate exact position with interpolation
    const exactIndex = progress * (edgePoints.length - 1);
    const lowerIndex = Math.floor(exactIndex);
    const upperIndex = Math.min(lowerIndex + 1, edgePoints.length - 1);
    const interpolationFactor = exactIndex - lowerIndex;
    
    // Interpolate between points for smoother movement
    const x = edgePoints[lowerIndex].x + (edgePoints[upperIndex].x - edgePoints[lowerIndex].x) * interpolationFactor;
    const y = edgePoints[lowerIndex].y + (edgePoints[upperIndex].y - edgePoints[lowerIndex].y) * interpolationFactor;
    
    // Position the ball
    ball.style.left = `${x}px`;
    ball.style.top = `${y}px`;
    
    // Continue animation if not complete
    if (progress < 1) {
        animationId = requestAnimationFrame((timestamp) => animateAlongEdge(timestamp, edgePoints));
    }
}

// Fix for the function that's referenced but not properly implemented
function startCircularAnimation(phase, pathPoints, duration) {
    // Show the ball
    ball.style.display = 'block';
    
    // Convert duration to milliseconds
    animationDuration = duration * 1000;
    animationStartTime = null;
    
    // Start animation loop
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame((timestamp) => animateCircular(timestamp, pathPoints));
}

// Make sure the circular animation function properly uses the pathPoints
function animateCircular(timestamp, pathPoints) {
    if (!animationStartTime) animationStartTime = timestamp;
    if (!isRunning) return;
    
    const elapsedTime = timestamp - animationStartTime;
    const progress = Math.min(elapsedTime / animationDuration, 1);
    
    // Calculate position along the circular path
    const pointIndex = Math.floor(progress * (pathPoints.length - 1));
    
    if (pointIndex >= 0 && pointIndex < pathPoints.length) {
        const point = pathPoints[pointIndex];
        
        // Position the ball
        ball.style.left = `${point.x}px`;
        ball.style.top = `${point.y}px`;
    }
    
    // Continue animation if not complete
    if (progress < 1) {
        animationId = requestAnimationFrame((timestamp) => animateCircular(timestamp, pathPoints));
    }
}

// Add glowing effect Start --------------------------------------------------------------
// Updated function to apply glowing effect with animation
function applyGlowEffect() {
    const phase = phasesData[currentPhaseIndex];
    if (!phase) return;
    
    const shape = phase.shape.toLowerCase();
    
    // Define specific colors for each shape using the color values you specified
    const blueGlow = 'rgb(52, 152, 219)';
    const blueBorder = 'rgb(0, 153, 255)';
    
    // Add transition property for smooth animation to shape and ball
    shapeElement.style.transition = "filter 0.8s ease, box-shadow 0.8s ease, border 0.8s ease";
    ball.style.transition = "background-color 0.8s ease, box-shadow 0.8s ease";
    
    if (shape === 'triangle') {
        // For triangle, apply glow to the :before pseudo-element
        shapeElement.style.filter = `drop-shadow(0 0 10px ${blueGlow}) drop-shadow(0 0 20px ${blueGlow})`;
        // Update the triangle border color
        updateTriangleGlowColor(blueBorder);
    } 
    else if (shape === 'reversedtriangle') {
        // For reversed triangle, apply glow to the :before pseudo-element
        shapeElement.style.filter = `drop-shadow(0 0 10px ${blueGlow}) drop-shadow(0 0 20px ${blueGlow})`;
        // Update the reversed triangle border color
        updateReversedTriangleGlowColor(blueBorder);
    }
    else {
        // For regular shapes, use box-shadow with the specific blue
        shapeElement.style.boxShadow = `0 0 15px ${blueGlow}, 0 0 30px ${blueGlow}`;
        shapeElement.style.border = `2px solid ${blueBorder}`;
    }
    
    // Apply matching color to the ball
    ball.style.backgroundColor = '#ffffff'; // white background
    ball.style.boxShadow = `0 0 10px ${blueGlow}, 0 0 20px ${blueGlow}`;
}

// Function to update triangle glow intensity based on breathing phase with animation
function updateGlowIntensity(breathingPhase) {
    const phase = phasesData[currentPhaseIndex];
    if (!phase) return;
    
    const shape = phase.shape.toLowerCase();
    
    // Use the specific blue colors you requested
    const blueGlow = 'rgb(52, 152, 219)';
    const blueBorder = 'rgb(0, 153, 255)';
    
    // Ensure transitions are set for smooth animation
    shapeElement.style.transition = "filter 1.2s ease, box-shadow 1.2s ease";
    ball.style.transition = "box-shadow 1.2s ease";
    
    // Adjust glow intensity based on breathing phase
    if (breathingPhase.toLowerCase().includes('inhale')) {
        // Stronger glow for inhale
        if (shape === 'triangle' || shape === 'reversedtriangle') {
            shapeElement.style.filter = `drop-shadow(0 0 15px ${blueGlow}) drop-shadow(0 0 30px ${blueGlow})`;
        } else {
            shapeElement.style.boxShadow = `0 0 25px ${blueGlow}, 0 0 40px ${blueGlow}`;
        }
        ball.style.boxShadow = `0 0 15px ${blueGlow}, 0 0 30px ${blueGlow}`;
    } else {
        // Softer glow for exhale
        if (shape === 'triangle' || shape === 'reversedtriangle') {
            shapeElement.style.filter = `drop-shadow(0 0 8px ${blueGlow}) drop-shadow(0 0 15px ${blueGlow})`;
        } else {
            shapeElement.style.boxShadow = `0 0 10px ${blueGlow}, 0 0 20px ${blueGlow}`;
        }
        ball.style.boxShadow = `0 0 8px ${blueGlow}, 0 0 15px ${blueGlow}`;
    }
}

// Helper function to dynamically update triangle CSS with transitions
function updateTriangleGlowColor(color) {
    // Create or update the style element for triangle
    let styleEl = document.getElementById('triangle-glow-style');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'triangle-glow-style';
        document.head.appendChild(styleEl);
    }
    
    // Set the CSS with the current color and transition
    styleEl.textContent = `
        .triangle:before {
            border-bottom-color: ${color} !important;
            transition: border-bottom-color 0.8s ease !important;
        }
    `;
}

// Helper function to dynamically update reversed triangle CSS with transitions
function updateReversedTriangleGlowColor(color) {
    // Create or update the style element for reversed triangle
    let styleEl = document.getElementById('reversed-triangle-glow-style');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'reversed-triangle-glow-style';
        document.head.appendChild(styleEl);
    }
    
    // Set the CSS with the current color and transition
    styleEl.textContent = `
        .reversedtriangle:before {
            border-top-color: ${color} !important;
            transition: border-top-color 0.8s ease !important;
        }
    `;
}

// Add this initialization function to set up transitions when the app first loads
function initializeTransitions() {
    // Add initial transitions to shape element
    shapeElement.style.transition = "filter 0.8s ease, box-shadow 0.8s ease, border 0.8s ease";
    
    // Add initial transitions to ball
    ball.style.transition = "background-color 0.8s ease, box-shadow 0.8s ease";
    
    // Set up the pseudo-element transitions
    const initialStyle = document.createElement('style');
    initialStyle.id = 'initial-transitions';
    initialStyle.textContent = `
        .triangle:before, .reversedtriangle:before {
            transition: border-color 0.8s ease !important;
        }
    `;
    document.head.appendChild(initialStyle);
}

// Call this function when your app initializes, after elements are created
// For example, add this to your window.onload or initialization function
// initializeTransitions();
// Add Glowing effect End ------------------------------------------------------------------

window.addEventListener('load', () => {
  if (phasesData && phasesData.length > 0) {
    const initialShape = phasesData[0].shape;
    
    // Create path for the initial shape after a small delay to ensure DOM is ready
    setTimeout(() => {
      createShapePath(initialShape);
      
      const shape = phasesData[0].shape.toLowerCase();
      
      // Make sure shapes are visible but without glow
      if (shape === 'triangle' || shape === 'reversedtriangle') {
        // For triangles, keep their border visible but without glow
        shapeElement.style.boxShadow = "none";
        shapeElement.style.filter = "none";
        if (shape === 'triangle') {
          updateTriangleGlowColor('rgba(0, 153, 255, 0.5)'); // Visible but subtle
        } else {
          updateReversedTriangleGlowColor('rgba(0, 153, 255, 0.5)'); // Visible but subtle
        }
      } else {
        // For other shapes, add a visible border
        shapeElement.style.boxShadow = "none";
        shapeElement.style.filter = "none";
        shapeElement.style.border = "1px solid white";
        shapeElement.style.outline = "none";
      }
      
      // Make sure ball has no glow
      if (ball) {
        ball.style.boxShadow = "none";
        ball.style.border = "none";
      }
    }, 100);
  }
  
  // Check for browser speech synthesis support
  if (!window.speechSynthesis) {
    console.warn("This browser doesn't support speech synthesis. Voice guidance won't work.");
  }
});

// Update paths when window is resized
window.addEventListener('resize', () => {
    // Clear existing paths
    Object.keys(shapePaths).forEach(key => delete shapePaths[key]);
    Object.keys(shapeEdges).forEach(key => delete shapeEdges[key]);
    
    // Recreate path for current shape
    if (phasesData && phasesData.length > 0) {
        const currentShape = phasesData[currentPhaseIndex].shape;
        createShapePath(currentShape);
    }
});
</script>
<style>
    .phase-info {
    font-size: 1.5em;
    color: #f7fafe;
}
#voice-toggle-button{
    display: none;
}
#voice-toggle-btn {
color: #fffefe;
}
</style>

<script>
    // Store the original speak method
    const originalSpeak = window.speechSynthesis.speak;
    let voiceMuted = true; // Default to muted
    
    // Immediately mute on page load
    (function() {
        // Override the speak method with an empty function
        window.speechSynthesis.speak = function() {
            console.log("Speech attempt blocked");
            return;
        };
    })();
    
    function toggleVoice() {
        const button = document.getElementById('voice-toggle-button');
        const icon = button.querySelector('i');
    
        if (voiceMuted) {
            // Restore original functionality
            window.speechSynthesis.speak = originalSpeak;
            icon.className = "fas fa-microphone"; // 🎤 Icon when active
            voiceMuted = false;
        } else {
            // Cancel any current speech
            window.speechSynthesis.cancel();
            
            // Override the speak method with an empty function
            window.speechSynthesis.speak = function() {
                console.log("Speech attempt blocked");
                return;
            };
            
            icon.className = "fas fa-microphone-slash"; // ❌🎤 Icon when muted
            voiceMuted = true;
        }
    }
    
    // Add button if it doesn't exist
    document.addEventListener('DOMContentLoaded', function() {
        if (!document.getElementById('voice-toggle-button')) {
            const button = document.createElement('button');
            button.id = 'voice-toggle-button';
            button.innerHTML = '<i class="fas fa-microphone-slash"></i>'; // default icon on load (muted)
            button.onclick = toggleVoice;
            document.body.prepend(button);
        }
    });
    </script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
</body>
</html>