<!-- templates/exercises/exercise_play.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ exercise.name }} - Breathing Exercise</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f9fc;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .back-btn {
            background-color: transparent;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }
        .exercise-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }
        .shape-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .phase-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            color: #2c3e50;
        }
        
        /* Shape styles */
        .circle {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            border: 4px solid #3498db;
            position: relative;
        }
        .square {
            width: 250px;
            height: 250px;
            border: 4px solid #9b59b6;
            position: relative;
        }
        .rectangle {
            width: 300px;
            height: 150px;
            border: 4px solid #e74c3c;
            position: relative;
        }
        .oval {
            width: 300px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid #f39c12;
            position: relative;
        }
        .triangle {
            position: relative;
            width: 250px;
            height: 216px; /* Height for equilateral triangle */
        }
        .triangle:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-left: 125px solid transparent;
            border-right: 125px solid transparent;
            border-bottom: 216px solid transparent;
            border-bottom-color: #2ecc71;
            z-index: 1;
        }
        .reversedtriangle {
            position: relative;
            width: 250px;
            height: 216px; /* Height for equilateral triangle */
        }
        .reversedtriangle:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-left: 125px solid transparent;
            border-right: 125px solid transparent;
            border-top: 216px solid transparent;
            border-top-color: #1abc9c;
            z-index: 1;
        }
        .quadrilateral {
            width: 200px;
            height: 200px;
            transform: rotate(45deg);
            border: 4px solid #27ae60;
            position: relative;
        }
        
        /* Ball styles */
        .ball {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        
        .controls {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .start-btn {
            background-color: #2ecc71;
            color: white;
        }
        .pause-btn {
            background-color: #f39c12;
            color: white;
        }
        .reset-btn {
            background-color: #e74c3c;
            color: white;
        }
        .progress-info {
            margin-top: 20px;
            text-align: center;
            font-size: 1.2rem;
            color: #2c3e50;
        }
        
        /* Path for debugging - can be removed in production */
        .debug-path {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>{{ exercise.name }} ({{ exercise.difficulty }})</div>
    </div>
    
    <div class="container">
        <div class="exercise-display">
            <div class="shape-container">
                <div class="phase-info"></div>
                <div id="shape-element" class=""></div>
                <div id="ball" class="ball" style="display: none;"></div>
                <svg id="debug-path" class="debug-path" width="300" height="300" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
            
            <div class="controls">
                <button class="start-btn" id="start-btn">Start</button>
                <button class="pause-btn" id="pause-btn" disabled>Pause</button>
                <button class="reset-btn" id="reset-btn" disabled>Reset</button>
            </div>
            
            <div class="progress-info">
                <div id="phase-progress">Ready to start</div>
                <div id="cycle-progress"></div>
            </div>
        </div>
    </div>
    
<script>
    // Get exercise phases data from Django
const phasesData = {{ phases_data|safe }};

// DOM elements
const shapeElement = document.getElementById('shape-element');
const ball = document.getElementById('ball');
const debugPath = document.getElementById('debug-path');
const phaseInfo = document.querySelector('.phase-info');
const phaseProgress = document.getElementById('phase-progress');
const cycleProgress = document.getElementById('cycle-progress');
const startBtn = document.getElementById('start-btn');
const pauseBtn = document.getElementById('pause-btn');
const resetBtn = document.getElementById('reset-btn');

// Current state
let currentPhaseIndex = 0;
let currentBreathingPhaseIndex = 0;
let currentEdgeIndex = 0;
let currentCycle = 1;
let isRunning = false;
let timer = null;
let animationId = null;

// Ball animation parameters
let ballPosition = 0;
let animationStartTime = null;
let animationDuration = 5000; // Default duration (ms)

// Path coordinates for each shape
const shapePaths = {};

// Edge segments for multi-edge shapes
const shapeEdges = {};

// Initialize
updateShapeDisplay();

// Event listeners
startBtn.addEventListener('click', startExercise);
pauseBtn.addEventListener('click', pauseExercise);
resetBtn.addEventListener('click', resetExercise);

function startExercise() {
    if (!isRunning) {
        isRunning = true;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        resetBtn.disabled = false;
        runCurrentEdge();
    }
}

function pauseExercise() {
    if (isRunning) {
        isRunning = false;
        clearTimeout(timer);
        cancelAnimationFrame(animationId);
        startBtn.disabled = false;
        startBtn.textContent = 'Resume';
    }
}

function resetExercise() {
    isRunning = false;
    clearTimeout(timer);
    cancelAnimationFrame(animationId);
    currentPhaseIndex = 0;
    currentBreathingPhaseIndex = 0;
    currentEdgeIndex = 0;
    currentCycle = 1;
    startBtn.disabled = false;
    startBtn.textContent = 'Start';
    pauseBtn.disabled = true;
    resetBtn.disabled = true;
    ball.style.display = 'none';
    updateShapeDisplay();
}

function runCurrentEdge() {
    if (!isRunning) return;
    
    const phase = phasesData[currentPhaseIndex];
    if (!phase) {
        // Exercise completed
        resetExercise();
        phaseProgress.textContent = 'Exercise completed!';
        return;
    }
    
    // Update shape display for current phase
    updateShapeDisplay();
    
    // Create path for the current shape if it doesn't exist
    createShapePath(phase.shape);
    
    // Get total number of edges for this shape
    const totalEdges = getEdgeCount(phase.shape);
    
    // Get current breathing phase
    const breathingPhases = phase.breathing_phases;
    const currentBreathingPhase = breathingPhases[currentBreathingPhaseIndex];
    
    // Determine if this is a circular shape
    const isCircularShape = ['circle', 'oval'].includes(phase.shape.toLowerCase());
    
    // Get duration for current edge/phase
    let duration;
    if (isCircularShape) {
        // For circle/oval, use the specified duration for each half (inhale/exhale)
        duration = phase.inputs[currentBreathingPhaseIndex] || 0;
    } else {
        // For other shapes, use the specified duration for each edge
        duration = phase.inputs[0] || 0;
    }
    
    // Update display
    updateBreathingPhaseDisplay(phase.shape, currentBreathingPhase, duration);
    
    // For multi-edge shapes, we need to determine which edge to animate
    let edgePoints;
    
    if (isCircularShape) {
        // For circular shapes, use the full path for animation
        edgePoints = shapePaths[phase.shape];
    } else {
        // For shapes with distinct edges, use the appropriate edge
        edgePoints = shapeEdges[phase.shape][currentEdgeIndex];
    }
    
    // Start ball animation for this edge
    if (isCircularShape) {
        // For circular shapes, use full circle animation with different starting points
        // Start from 12 o'clock (top) for inhale and continue to complete a full circle
        startCircularAnimation(phase, edgePoints, duration);
    } else {
        // For other shapes, we animate along the edge
        startEdgeAnimation(phase, edgePoints, duration);
    }
    
    // Schedule next edge
    timer = setTimeout(() => {
        goToNextEdge(phase);
    }, duration * 1000);
}

function getEdgeCount(shape) {
    switch(shape.toLowerCase()) {
        case 'circle':
        case 'oval':
            return 1; // Circular shapes are treated specially
        case 'triangle':
        case 'reversedtriangle':
            return 3;
        case 'square':
        case 'rectangle':
        case 'quadrilateral':
            return 4;
        default:
            return 1;
    }
}

function goToNextEdge(phase) {
    const isCircularShape = ['circle', 'oval'].includes(phase.shape.toLowerCase());
    const totalEdges = getEdgeCount(phase.shape);
    
    // Update breathing phase index
    currentBreathingPhaseIndex = (currentBreathingPhaseIndex + 1) % phase.breathing_phases.length;
    
    // For non-circular shapes, update edge index
    if (!isCircularShape) {
        currentEdgeIndex = (currentEdgeIndex + 1) % totalEdges;
        
        // If we've completed all edges, increment cycle
        if (currentEdgeIndex === 0) {
            currentCycle++;
        }
    } else {
        // For circular shapes, if we've completed all breathing phases, increment cycle
        if (currentBreathingPhaseIndex === 0) {
            currentCycle++;
        }
    }
    
    // Check if we completed all cycles for this shape
    if (currentCycle > phase.cycles) {
        currentCycle = 1;
        currentEdgeIndex = 0;
        currentBreathingPhaseIndex = 0;
        currentPhaseIndex++;
        
        // Force shape update for the next phase
        updateShapeDisplay();
    }
    
    runCurrentEdge();
}

function updateBreathingPhaseDisplay(shape, breathingPhase, duration) {
    // Clear previous classes
    shapeElement.className = '';
    
    // Set shape class
    shapeElement.classList.add(shape.toLowerCase());
    
    // Update text displays
    phaseInfo.textContent = breathingPhase;
    phaseProgress.textContent = `Phase: ${currentPhaseIndex + 1}/${phasesData.length} - ${breathingPhase} (${duration}s)`;
    cycleProgress.textContent = `Cycle: ${currentCycle}/${phasesData[currentPhaseIndex].cycles}`;
}

function updateShapeDisplay() {
    const phase = phasesData[currentPhaseIndex];
    if (!phase) return;
    
    // Clear previous classes
    shapeElement.className = '';
    
    // Set shape class
    shapeElement.classList.add(phase.shape.toLowerCase());
    
    // Reset text displays
    if (!isRunning) {
        phaseInfo.textContent = 'Ready';
        phaseProgress.textContent = 'Ready to start';
        cycleProgress.textContent = `Phase: ${currentPhaseIndex + 1}/${phasesData.length}`;
    }
    
    // Important: Clear previous paths for this shape to force recalculation
    delete shapePaths[phase.shape];
    delete shapeEdges[phase.shape];
    
    // Create path for the shape
    createShapePath(phase.shape);
}

function createShapePath(shape) {
    // Don't recreate if already exists
    if (shapePaths[shape]) return;
    
    // Get shape element dimensions
    const shapeRect = shapeElement.getBoundingClientRect();
    const containerRect = document.querySelector('.shape-container').getBoundingClientRect();
    
    // Adjust coordinates to be relative to container
    const offsetX = shapeRect.left - containerRect.left;
    const offsetY = shapeRect.top - containerRect.top;
    
    // Path points array
    let points = [];
    let edges = [];
    
    switch(shape.toLowerCase()) {
        case 'circle':
            // Create points around a circle
            const circleRadius = shapeRect.width / 2;
            const centerX = offsetX + circleRadius;
            const centerY = offsetY + circleRadius;
            
            // Create more points for smoother animation (360 points for a circle - one per degree)
            // Start from the top (12 o'clock) position: -90 degrees in radians is -Math.PI/2
            for (let i = 0; i <= 360; i++) {
                const angle = ((i / 360) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = centerX + Math.cos(angle) * circleRadius;
                const y = centerY + Math.sin(angle) * circleRadius;
                points.push({ x, y });
            }
            break;
            
        case 'square':
            // Create points around a square
            const squareLeft = offsetX;
            const squareTop = offsetY;
            const squareRight = offsetX + shapeRect.width;
            const squareBottom = offsetY + shapeRect.height;
            
            // Top edge (left to right)
            const topEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = squareLeft + (squareRight - squareLeft) * (i / 100);
                topEdge.push({ x, y: squareTop });
            }
            
            // Right edge (top to bottom)
            const rightEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = squareTop + (squareBottom - squareTop) * (i / 100);
                rightEdge.push({ x: squareRight, y });
            }
            
            // Bottom edge (right to left)
            const bottomEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = squareRight - (squareRight - squareLeft) * (i / 100);
                bottomEdge.push({ x, y: squareBottom });
            }
            
            // Left edge (bottom to top)
            const leftEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = squareBottom - (squareBottom - squareTop) * (i / 100);
                leftEdge.push({ x: squareLeft, y });
            }
            
            // Store edges separately for phase tracking
            edges = [topEdge, rightEdge, bottomEdge, leftEdge];
            points = [...topEdge, ...rightEdge, ...bottomEdge, ...leftEdge];
            break;
            
        case 'rectangle':
            // Create points around a rectangle
            const rectLeft = offsetX;
            const rectTop = offsetY;
            const rectRight = offsetX + shapeRect.width;
            const rectBottom = offsetY + shapeRect.height;
            
            // Top edge (left to right)
            const rectTopEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = rectLeft + (rectRight - rectLeft) * (i / 100);
                rectTopEdge.push({ x, y: rectTop });
            }
            
            // Right edge (top to bottom)
            const rectRightEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = rectTop + (rectBottom - rectTop) * (i / 100);
                rectRightEdge.push({ x: rectRight, y });
            }
            
            // Bottom edge (right to left)
            const rectBottomEdge = [];
            for (let i = 0; i <= 100; i++) {
                const x = rectRight - (rectRight - rectLeft) * (i / 100);
                rectBottomEdge.push({ x, y: rectBottom });
            }
            
            // Left edge (bottom to top)
            const rectLeftEdge = [];
            for (let i = 0; i <= 100; i++) {
                const y = rectBottom - (rectBottom - rectTop) * (i / 100);
                rectLeftEdge.push({ x: rectLeft, y });
            }
            
            // Store edges separately for phase tracking
            edges = [rectTopEdge, rectRightEdge, rectBottomEdge, rectLeftEdge];
            points = [...rectTopEdge, ...rectRightEdge, ...rectBottomEdge, ...rectLeftEdge];
            break;
            
        case 'oval':
            // Create points around an oval
            const ovalRadiusX = shapeRect.width / 2;
            const ovalRadiusY = shapeRect.height / 2;
            const ovalCenterX = offsetX + ovalRadiusX;
            const ovalCenterY = offsetY + ovalRadiusY;
            
            // Create more points for smoother animation (360 points for an oval - one per degree)
            // Start from the top (12 o'clock) position: -90 degrees in radians is -Math.PI/2
            for (let i = 0; i <= 360; i++) {
                const angle = ((i / 360) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = ovalCenterX + Math.cos(angle) * ovalRadiusX;
                const y = ovalCenterY + Math.sin(angle) * ovalRadiusY;
                points.push({ x, y });
            }
            break;
            
        case 'triangle':
            // Create points for an equilateral triangle
            const triWidth = shapeRect.width;
            const triHeight = shapeRect.height;
            
            // Calculate the three points of the triangle
            const triLeft = offsetX;
            const triTop = offsetY;
            
            // Define the three vertices precisely
            const point1 = { x: triLeft + triWidth/2, y: triTop }; // Top
            const point2 = { x: triLeft, y: triTop + triHeight }; // Bottom-left
            const point3 = { x: triLeft + triWidth, y: triTop + triHeight }; // Bottom-right
            
            // Left edge (top to bottom-left)
            const triLeftEdge = createLinePoints(point1, point2, 100);
            
            // Bottom edge (bottom-left to bottom-right)
            const triBottomEdge = createLinePoints(point2, point3, 100);
            
            // Right edge (bottom-right to top)
            const triRightEdge = createLinePoints(point3, point1, 100);
            
            edges = [triLeftEdge, triBottomEdge, triRightEdge];
            points = [...triLeftEdge, ...triBottomEdge, ...triRightEdge];
            break;
            
        case 'reversedtriangle':
            // Create points for a reversed equilateral triangle
            const revTriWidth = shapeRect.width;
            const revTriHeight = shapeRect.height;
            
            // Calculate the three points of the triangle
            const revTriLeft = offsetX;
            const revTriTop = offsetY;
            
            const revPoint1 = { x: revTriLeft + revTriWidth/2, y: revTriTop + revTriHeight }; // Bottom
            const revPoint2 = { x: revTriLeft, y: revTriTop }; // Top-left
            const revPoint3 = { x: revTriLeft + revTriWidth, y: revTriTop }; // Top-right
            
            // Right edge (bottom to top-right)
            const revRightSegmentPoints = createLinePoints(revPoint1, revPoint3, 100);
            // Top edge (top-right to top-left)
            const revTopSegmentPoints = createLinePoints(revPoint3, revPoint2, 100);
            // Left edge (top-left to bottom)
            const revLeftSegmentPoints = createLinePoints(revPoint2, revPoint1, 100);
            
            edges = [revRightSegmentPoints, revTopSegmentPoints, revLeftSegmentPoints];
            points = [...revRightSegmentPoints, ...revTopSegmentPoints, ...revLeftSegmentPoints];
            break;
            
        case 'quadrilateral':
            // Create points for a diamond (rotated square)
            const diamondSize = Math.min(shapeRect.width, shapeRect.height);
            const diamondCenterX = offsetX + shapeRect.width / 2;
            const diamondCenterY = offsetY + shapeRect.height / 2;
            
            // Calculate the four points of the rotated square
            const dTop = { x: diamondCenterX, y: diamondCenterY - diamondSize/2 };
            const dRight = { x: diamondCenterX + diamondSize/2, y: diamondCenterY };
            const dBottom = { x: diamondCenterX, y: diamondCenterY + diamondSize/2 };
            const dLeft = { x: diamondCenterX - diamondSize/2, y: diamondCenterY };
            
            // Create path segments with more points for smoother animation
            // Top-right edge
            const topRightPoints = createLinePoints(dTop, dRight, 100);
            // Bottom-right edge
            const bottomRightPoints = createLinePoints(dRight, dBottom, 100);
            // Bottom-left edge
            const bottomLeftPoints = createLinePoints(dBottom, dLeft, 100);
            // Top-left edge
            const topLeftPoints = createLinePoints(dLeft, dTop, 100);
            
            edges = [topRightPoints, bottomRightPoints, bottomLeftPoints, topLeftPoints];
            points = [...topRightPoints, ...bottomRightPoints, ...bottomLeftPoints, ...topLeftPoints];
            break;
            
        default:
            // Default fallback for any unsupported shapes
            const fallbackRadius = Math.min(shapeRect.width, shapeRect.height) / 2;
            const fallbackCenterX = offsetX + shapeRect.width / 2;
            const fallbackCenterY = offsetY + shapeRect.height / 2;
            
            for (let i = 0; i <= 100; i++) {
                const angle = ((i / 100) * Math.PI * 2) - Math.PI/2; // Start from top (12 o'clock)
                const x = fallbackCenterX + Math.cos(angle) * fallbackRadius;
                const y = fallbackCenterY + Math.sin(angle) * fallbackRadius;
                points.push({ x, y });
            }
    }
    
    // Store the path and edges
    shapePaths[shape] = points;
    shapeEdges[shape] = edges.length > 0 ? edges : [points];
    
    // Debug: Draw path on canvas (uncomment for debugging)
    // drawDebugPath(points);
}

function createLinePoints(start, end, numPoints) {
    const points = [];
    for (let i = 0; i <= numPoints; i++) {
        const ratio = i / numPoints;
        const x = start.x + (end.x - start.x) * ratio;
        const y = start.y + (end.y - start.y) * ratio;
        points.push({ x, y });
    }
    return points;
}

// Debug function to visualize the path
function drawDebugPath(points) {
    // Clear previous path
    while (debugPath.firstChild) {
        debugPath.removeChild(debugPath.firstChild);
    }
    
    if (points.length < 2) return;
    
    // Create a path element
    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    
    // Build path data
    let pathData = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
        pathData += ` L ${points[i].x} ${points[i].y}`;
    }
    pathData += ' Z'; // Close the path
    
    // Set path attributes
    pathElement.setAttribute('d', pathData);
    pathElement.setAttribute('stroke', 'red');
    pathElement.setAttribute('stroke-width', '2');
    pathElement.setAttribute('fill', 'none');
    
    // Add path to SVG
    debugPath.appendChild(pathElement);
    debugPath.style.opacity = '0.5'; // Make visible for debugging
}

// Function for edge animation (non-circular shapes)
function startEdgeAnimation(phase, edgePoints, duration) {
    // Show the ball
    ball.style.display = 'block';
    
    // Convert duration to milliseconds
    animationDuration = duration * 1000;
    animationStartTime = null;
    
    // Start animation loop
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame((timestamp) => animateAlongEdge(timestamp, edgePoints));
}

// Animation loop for non-circular shapes
function animateAlongEdge(timestamp, edgePoints) {
    if (!animationStartTime) animationStartTime = timestamp;
    if (!isRunning) return;
    
    const elapsedTime = timestamp - animationStartTime;
    const progress = Math.min(elapsedTime / animationDuration, 1);
    
    // Calculate current position on the edge
    const pointIndex = Math.floor(progress * (edgePoints.length - 1));
    
    if (pointIndex >= 0 && pointIndex < edgePoints.length) {
        const point = edgePoints[pointIndex];
        
        // Position the ball
        ball.style.left = `${point.x}px`;
        ball.style.top = `${point.y}px`;
    }
    
    // Continue animation if not complete
    if (progress < 1) {
        animationId = requestAnimationFrame((timestamp) => animateAlongEdge(timestamp, edgePoints));
    }
}

// Updated circular animation function - always do full circle
function startCircularAnimation(phase, pathPoints, duration) {
    // Show the ball
    ball.style.display = 'block';
    
    // Convert duration to milliseconds
    animationDuration = duration * 1000;
    animationStartTime = null;
    
    // Start animation loop
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame((timestamp) => animateCircular(timestamp, pathPoints));
}

// Updated animation loop for circular shapes - always do full circle
function animateCircular(timestamp, pathPoints) {
    if (!animationStartTime) animationStartTime = timestamp;
    if (!isRunning) return;
    
    const elapsedTime = timestamp - animationStartTime;
    const progress = Math.min(elapsedTime / animationDuration, 1);
    
    // Always animate the full circle (0 to 1)
    const positionRatio = progress;
    
    // Calculate point index based on position ratio
    const pointIndex = Math.floor(positionRatio * (pathPoints.length - 1));
    
    if (pointIndex >= 0 && pointIndex < pathPoints.length) {
        const point = pathPoints[pointIndex];
        
        // Position the ball
        ball.style.left = `${point.x}px`;
        ball.style.top = `${point.y}px`;
    }
    
    // Continue animation if not complete
    if (progress < 1) {
        animationId = requestAnimationFrame((timestamp) => animateCircular(timestamp, pathPoints));
    }
}

// Wait for DOM to be fully loaded before calculating initial paths
window.addEventListener('load', () => {
    if (phasesData && phasesData.length > 0) {
        const initialShape = phasesData[0].shape;
        // Create path for the initial shape after a small delay to ensure DOM is ready
        setTimeout(() => createShapePath(initialShape), 100);
    }
});

// Update paths when window is resized
window.addEventListener('resize', () => {
    // Clear existing paths
    Object.keys(shapePaths).forEach(key => delete shapePaths[key]);
    Object.keys(shapeEdges).forEach(key => delete shapeEdges[key]);
    
    // Recreate path for current shape
    if (phasesData && phasesData.length > 0) {
        const currentShape = phasesData[currentPhaseIndex].shape;
        createShapePath(currentShape);
    }
});
</script>
</body>
</html>