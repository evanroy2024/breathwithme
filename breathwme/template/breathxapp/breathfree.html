<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Mobile Haptic Test</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      color: white;
    }

    .container {
      max-width: 400px;
      margin: 0 auto;
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      margin: 0 0 10px 0;
      font-size: 24px;
      font-weight: 600;
    }

    .device-info {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 14px;
      line-height: 1.4;
    }

    .test-section {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
    }

    .haptic-btn {
      width: 100%;
      padding: 18px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 15px;
      background: linear-gradient(45deg, #ff6b6b, #ff8e53);
      color: white;
      cursor: pointer;
      margin-bottom: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .haptic-btn:active {
      transform: scale(0.98);
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .haptic-btn:disabled {
      background: #888;
      cursor: not-allowed;
      transform: none;
    }

    .intensity-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .intensity-btn {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      background: transparent;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .intensity-btn.active {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.6);
    }

    .status {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      font-size: 14px;
      line-height: 1.5;
      max-height: 200px;
      overflow-y: auto;
    }

    .status-item {
      margin-bottom: 8px;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .status-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .error { color: #ff6b6b; }
    .success { color: #51cf66; }
    .warning { color: #ffd43b; }
    .info { color: #74c0fc; }

    .diagnostic-info {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 10px;
    }
  </style>
</head>
<body>

  <div class="container">
    <div class="header">
      <h1>üîÆ Haptic Test</h1>
      <div id="deviceInfo" class="device-info">Detecting device...</div>
    </div>

    <div class="test-section">
      <h3>Vibration Intensity</h3>
      <div class="intensity-controls">
        <button class="intensity-btn active" data-intensity="light">Light</button>
        <button class="intensity-btn" data-intensity="medium">Medium</button>
        <button class="intensity-btn" data-intensity="strong">Strong</button>
      </div>

      <button id="testHaptic" class="haptic-btn">
        üî• Test Haptic Feedback
      </button>

      <button id="testPattern" class="haptic-btn">
        üéµ Test Pattern Vibration
      </button>

      <div id="status" class="status">
        <div class="status-item info">Ready to test haptic feedback...</div>
      </div>
    </div>
  </div>

  <script>
    class HapticTester {
      constructor() {
        this.currentIntensity = 'medium';
        this.statusEl = document.getElementById('status');
        this.deviceInfoEl = document.getElementById('deviceInfo');
        this.logHistory = [];
        
        this.init();
      }
      
      init() {
        this.detectDevice();
        this.setupEventListeners();
        this.performDiagnostics();
      }
      
      detectDevice() {
        const userAgent = navigator.userAgent;
        const platform = navigator.platform;
        const isIOS = /iPad|iPhone|iPod/.test(userAgent) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const isAndroid = /Android/.test(userAgent);
        const isMobile = /Mobi|Android/i.test(userAgent) || isIOS;
        
        let deviceInfo = `
          <strong>Device Detection:</strong><br>
          üì± Platform: ${isIOS ? 'iOS' : isAndroid ? 'Android' : 'Other'}<br>
          üìü Mobile: ${isMobile ? 'Yes' : 'No'}<br>
          üåê Browser: ${this.getBrowserName()}<br>
          üîí HTTPS: ${location.protocol === 'https:' ? 'Yes' : 'No'}
        `;
        
        this.deviceInfoEl.innerHTML = deviceInfo;
        
        return {
          isIOS,
          isAndroid,
          isMobile,
          browser: this.getBrowserName()
        };
      }
      
      getBrowserName() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome') && !ua.includes('Edg')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
        if (ua.includes('Edg')) return 'Edge';
        return 'Unknown';
      }
      
      setupEventListeners() {
        // Intensity buttons
        document.querySelectorAll('.intensity-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            document.querySelectorAll('.intensity-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            this.currentIntensity = e.target.dataset.intensity;
            this.log(`Intensity set to: ${this.currentIntensity}`, 'info');
          });
        });
        
        // Test buttons
        document.getElementById('testHaptic').addEventListener('click', () => {
          this.testHapticFeedback();
        });
        
        document.getElementById('testPattern').addEventListener('click', () => {
          this.testPatternVibration();
        });
      }
      
      async performDiagnostics() {
        this.log('üîç Starting diagnostics...', 'info');
        
        // Check basic requirements
        await this.checkBasicRequirements();
        
        // Check permissions
        await this.checkPermissions();
        
        // Test availability
        this.testAvailability();
        
        this.log('‚úÖ Diagnostics complete', 'success');
      }
      
      async checkBasicRequirements() {
        const device = this.detectDevice();
        
        // HTTPS check
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
          this.log('‚ö†Ô∏è HTTPS required for vibration API in production', 'warning');
        }
        
        // Mobile check
        if (!device.isMobile) {
          this.log('‚ö†Ô∏è Not detected as mobile device - vibration may not work', 'warning');
        }
        
        // User activation check
        if (!document.hasStoredUserActivation && !document.userActivation?.hasBeenActive) {
          this.log('‚ÑπÔ∏è User interaction required before vibration works', 'info');
        }
      }
      
      async checkPermissions() {
        try {
          // Check notification permission (sometimes related to vibration)
          if ('permissions' in navigator) {
            const result = await navigator.permissions.query({name: 'notifications'});
            this.log(`üìã Notification permission: ${result.state}`, 'info');
          }
        } catch (error) {
          this.log(`‚ùå Permission check failed: ${error.message}`, 'error');
        }
      }
      
      testAvailability() {
        let available = [];
        let unavailable = [];
        
        // Test native vibration
        if ('vibrate' in navigator) {
          available.push('Native Vibration API');
        } else {
          unavailable.push('Native Vibration API');
        }
        
        // Test WebKit haptic (iOS)
        if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
          available.push('iOS Motion/Haptic API');
        }
        
        // Test Gamepad haptics
        if ('getGamepads' in navigator) {
          available.push('Gamepad Haptic API');
        } else {
          unavailable.push('Gamepad Haptic API');
        }
        
        // Test Web Haptics (experimental)
        if ('haptics' in navigator) {
          available.push('Web Haptics API (Experimental)');
        }
        
        if (available.length > 0) {
          this.log(`‚úÖ Available: ${available.join(', ')}`, 'success');
        }
        
        if (unavailable.length > 0) {
          this.log(`‚ùå Unavailable: ${unavailable.join(', ')}`, 'error');
        }
      }
      
      async testHapticFeedback() {
        this.log(`üî• Testing ${this.currentIntensity} haptic feedback...`, 'info');
        
        let success = false;
        
        // Method 1: Native Vibration API
        success = await this.tryNativeVibration() || success;
        
        // Method 2: iOS-specific haptic
        success = await this.tryiOSHaptic() || success;
        
        // Method 3: Gamepad haptics
        success = await this.tryGamepadHaptic() || success;
        
        // Method 4: Web Haptics (experimental)
        success = await this.tryWebHaptics() || success;
        
        if (!success) {
          this.log('‚ùå All haptic methods failed', 'error');
          this.showTroubleshootingTips();
        }
      }
      
      async tryNativeVibration() {
        try {
          if (!('vibrate' in navigator)) {
            this.log('‚ùå Native vibration not supported', 'error');
            return false;
          }
          
          const patterns = {
            light: [50],
            medium: [100],
            strong: [200]
          };
          
          const pattern = patterns[this.currentIntensity];
          const result = navigator.vibrate(pattern);
          
          if (result) {
            this.log(`‚úÖ Native vibration triggered (${this.currentIntensity})`, 'success');
            return true;
          } else {
            this.log('‚ùå Native vibration failed - may be disabled', 'error');
            return false;
          }
        } catch (error) {
          this.log(`‚ùå Native vibration error: ${error.message}`, 'error');
          return false;
        }
      }
      
      async tryiOSHaptic() {
        try {
          // iOS Safari haptic feedback using audio context trick
          if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
              const audioContext = new AudioContext();
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              gainNode.gain.setValueAtTime(0, audioContext.currentTime);
              oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
              
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.1);
              
              this.log('‚úÖ iOS audio haptic triggered', 'success');
              return true;
            }
          }
          return false;
        } catch (error) {
          this.log(`‚ùå iOS haptic error: ${error.message}`, 'error');
          return false;
        }
      }
      
      async tryGamepadHaptic() {
        try {
          if (!('getGamepads' in navigator)) return false;
          
          const gamepads = navigator.getGamepads();
          let triggered = false;
          
          for (let gamepad of gamepads) {
            if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators.length > 0) {
              const intensity = this.currentIntensity === 'light' ? 0.3 : 
                              this.currentIntensity === 'medium' ? 0.6 : 1.0;
              
              await gamepad.hapticActuators[0].pulse(intensity, 100);
              triggered = true;
            }
          }
          
          if (triggered) {
            this.log('‚úÖ Gamepad haptic triggered', 'success');
            return true;
          }
          
          return false;
        } catch (error) {
          this.log(`‚ùå Gamepad haptic error: ${error.message}`, 'error');
          return false;
        }
      }
      
      async tryWebHaptics() {
        try {
          if ('haptics' in navigator) {
            await navigator.haptics.vibrate({
              duration: this.currentIntensity === 'light' ? 50 : 
                        this.currentIntensity === 'medium' ? 100 : 200
            });
            this.log('‚úÖ Web Haptics API triggered', 'success');
            return true;
          }
          return false;
        } catch (error) {
          this.log(`‚ùå Web Haptics error: ${error.message}`, 'error');
          return false;
        }
      }
      
      async testPatternVibration() {
        this.log('üéµ Testing pattern vibration...', 'info');
        
        try {
          if ('vibrate' in navigator) {
            // SOS pattern: ... --- ...
            const pattern = [100, 50, 100, 50, 100, 200, 200, 50, 200, 50, 200, 200, 100, 50, 100, 50, 100];
            
            const result = navigator.vibrate(pattern);
            
            if (result) {
              this.log('‚úÖ Pattern vibration triggered (SOS)', 'success');
            } else {
              this.log('‚ùå Pattern vibration failed', 'error');
            }
          } else {
            this.log('‚ùå Vibration not supported for patterns', 'error');
          }
        } catch (error) {
          this.log(`‚ùå Pattern vibration error: ${error.message}`, 'error');
        }
      }
      
      showTroubleshootingTips() {
        const tips = [
          'üì± Check if vibration is enabled in device settings',
          'üîã Disable battery saver mode if enabled',
          'üåê Use HTTPS instead of HTTP',
          'üëÜ Ensure user interaction before testing',
          'üîä Check if silent/do not disturb mode is on',
          'üîÑ Try refreshing the page',
          'üì≤ Test in different browsers (Chrome, Firefox, Safari)',
          '‚öôÔ∏è Check browser vibration permissions'
        ];
        
        this.log('üí° Troubleshooting tips:', 'warning');
        tips.forEach(tip => this.log(tip, 'info'));
      }
      
      log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;
        
        this.logHistory.push({message: logEntry, type});
        
        // Keep only last 20 entries
        if (this.logHistory.length > 20) {
          this.logHistory.shift();
        }
        
        this.updateStatusDisplay();
      }
      
      updateStatusDisplay() {
        this.statusEl.innerHTML = this.logHistory
          .map(entry => `<div class="status-item ${entry.type}">${entry.message}</div>`)
          .join('');
        
        // Scroll to bottom
        this.statusEl.scrollTop = this.statusEl.scrollHeight;
      }
    }
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new HapticTester();
    });
    
    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // Re-run diagnostics when page becomes visible
        setTimeout(() => {
          if (window.hapticTester) {
            window.hapticTester.performDiagnostics();
          }
        }, 500);
      }
    });
  </script>

</body>
</html>